Perfect—Module 5 is where containers come alive. Up to now, we’ve just been _storing_ data. Now we’ll start _working_ with it: sorting, searching, and iterating. This is the bridge from “I can hold a list of numbers” to “I can process and transform data efficiently.” We’ll go line‑by‑line again, assuming only your Python/JS background.

---

# Module 5: Algorithms on Containers

**Sorting, Searching, and Iteration Patterns**

**Time**: ~2 hours  
**Goals**:

- Learn how to sort and search containers in C++ and Python.
- Understand iteration patterns (loops, iterators, ranges).
- Compare Python’s built‑ins (`sorted`, `in`, `for`) with C++’s `<algorithm>` library.
- Tie it back to Forge: sorting tool offsets, searching G‑code commands, iterating job queues.

---

## Step 1: Python Refresher

```python
tools = [30, 10, 20]

# Sort
tools.sort()             # in-place
print(tools)             # [10, 20, 30]

# Search
print(20 in tools)       # True
print(99 in tools)       # False

# Iteration
for t in tools:
    print(t)
```

- `list.sort()` → modifies the list in place.
- `in` → linear search (O(n)).
- Iteration is simple `for t in tools`.

---

## Step 2: C++ Sorting with `<algorithm>`

Create `src/forge_core/include/forge/core/algos.hpp`:

```cpp
#pragma once
namespace forge::core {
    void demo_sorting();
}
```

### Implementation: `algos.cpp`

```cpp
#include "forge/core/algos.hpp"
#include <vector>
#include <algorithm>  // for std::sort
#include <iostream>

namespace forge::core {

    void demo_sorting() {
        std::vector<int> tools = {30, 10, 20};

        std::sort(tools.begin(), tools.end());  // sort ascending

        std::cout << "Sorted tools:\n";
        for (int t : tools) {
            std::cout << t << "\n";
        }
    }

}
```

### Line‑by‑line

- `#include <algorithm>` → Brings in algorithms like `sort`, `find`, `count`.
- `std::sort(tools.begin(), tools.end());`
  - `tools.begin()` → iterator to first element.
  - `tools.end()` → iterator _past_ the last element.
  - `std::sort` sorts the range `[begin, end)`.
- `for (int t : tools)` → Range‑based loop prints each element.

**Echo:** This is like Python’s `tools.sort()`, but in C++ you pass iterators (start and end).

---

## Step 3: Custom Sorting

```cpp
std::sort(tools.begin(), tools.end(),
          [](int a, int b) { return a > b; });  // descending
```

- `[](int a, int b) { return a > b; }` → A **lambda function**.
- This comparator says: “put bigger numbers first.”
- Equivalent to Python’s `sorted(tools, reverse=True)`.

---

## Step 4: Searching

### Linear Search

```cpp
auto it = std::find(tools.begin(), tools.end(), 20);
if (it != tools.end()) {
    std::cout << "Found: " << *it << "\n";
} else {
    std::cout << "Not found\n";
}
```

- `std::find` → scans through the range.
- Returns an iterator to the element, or `end()` if not found.
- `*it` → dereference the iterator to get the value.

Equivalent to Python’s `if 20 in tools:`.

---

### Binary Search (on sorted data)

```cpp
bool exists = std::binary_search(tools.begin(), tools.end(), 20);
std::cout << (exists ? "Found" : "Not found") << "\n";
```

- `std::binary_search` → O(log n) search, but only works if the container is sorted.
- Equivalent to Python’s `bisect` module.

---

## Step 5: Iteration Patterns

### Index‑based loop

```cpp
for (size_t i = 0; i < tools.size(); i++) {
    std::cout << "tools[" << i << "] = " << tools[i] << "\n";
}
```

- `size_t` → unsigned integer type for sizes.
- `tools.size()` → number of elements.
- `tools[i]` → random access.

### Iterator loop

```cpp
for (auto it = tools.begin(); it != tools.end(); ++it) {
    std::cout << *it << "\n";
}
```

- `auto it = tools.begin();` → iterator to first element.
- `it != tools.end();` → loop until past the last element.
- `++it` → move to next element.
- `*it` → dereference to get the value.

This is verbose, but shows how iterators work under the hood.

---

## Step 6: Binding to Python

Expose `demo_sorting` in `forge_core_py.cpp`:

```cpp
#include <pybind11/pybind11.h>
#include <forge/core/algos.hpp>

namespace py = pybind11;

PYBIND11_MODULE(forge_core_py, m) {
    m.def("demo_sorting", &forge::core::demo_sorting);
}
```

Now in Python:

```python
import forge_core_py
forge_core_py.demo_sorting()
```

Output:

```
Sorted tools:
10
20
30
```

---

## Step 7: Forge Tie‑in

Imagine Forge needs to:

- Sort tool offsets by size.
- Search for a specific G‑code command.
- Iterate through a job queue.

These patterns (sort, search, iterate) are the building blocks. You’ll use them everywhere.

---

## Reflection & Repetition

- **Echo:** Sorting in Python (`list.sort`) vs. C++ (`std::sort`).
- **Why this matters:** Efficient searching/sorting is the backbone of algorithms.
- **Repetition cue:** We’ll revisit sorting/searching in Phase 3 (DSA), where we’ll implement quicksort, binary search trees, and graph traversals.
- **Pitfall:** `std::binary_search` only works on sorted data—forgetting that leads to bugs.

---

## Exercises

1. **Guided:** Modify `demo_sorting` to sort descending using a lambda.
2. **Stretch:** Write a function `find_tool` that searches for a tool ID in a vector and returns its index (or ‑1 if not found). Bind it to Python.
3. **Reflection:** Compare: Python hides iterators, C++ exposes them. Which feels clearer to you right now, and why?

---

✅ **End of Module 5**  
You now understand sorting, searching, and iteration patterns in C++ and Python. This is the first step toward algorithmic thinking.

---

Michael, do you want me to **continue into Module 6 (Error handling and robustness: exceptions, return codes, Python vs. C++ safety)**, or would you like me to **expand Module 5 further** with more repetition (e.g., deeper dive into iterators, complexity analysis, or memory layout diagrams)?
