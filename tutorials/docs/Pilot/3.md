

# Module 3: Lifetimes and Resource Management  
**C++ RAII vs. Python Context Managers**

**Time**: ~1.5–2 hours  
**Goals**:  
- Understand how C++ manages resources with RAII (Resource Acquisition Is Initialization).  
- Compare that to Python’s `with` statement (context managers).  
- Practice writing safe file‑handling code in both languages.  
- Tie it back to Forge: reading/writing files without leaks or crashes.  

---

## Step 1: Why This Matters

In Python/JS, you can often “forget” about cleanup because the garbage collector eventually frees memory. But in **C++**, you must be explicit: if you open a file, allocate memory, or lock a mutex, you must release it. Forgetting leads to leaks, crashes, or deadlocks.

RAII is C++’s philosophy: *when an object goes out of scope, its destructor automatically cleans up*.  
In Python, the equivalent is the `with` statement, which ensures cleanup even if an error occurs.

---

## Step 2: C++ RAII Example

Create `src/forge_core/include/forge/core/file.hpp`:

```cpp
#pragma once
#include <cstdio>   // for FILE*, fopen, fclose
#include <string>

namespace forge::core {

    class File {
    public:
        // Constructor: open the file
        File(const std::string& path, const char* mode);

        // Destructor: close the file
        ~File();

        // Write some text
        void write(const std::string& text);

    private:
        std::FILE* f;  // raw C file pointer
    };

}
```

### Line‑by‑line

- `#pragma once` → Prevents multiple inclusion.  
- `#include <cstdio>` → Brings in C standard I/O functions (`FILE*`, `fopen`, `fclose`).  
- `#include <string>` → For `std::string`.  
- `namespace forge::core { ... }` → Keeps our class inside the project namespace.  
- `class File { ... };` → Defines a class named `File`.  
- `public:` → Members accessible from outside.  
- `File(const std::string& path, const char* mode);` → Constructor: runs when you create a `File` object.  
- `~File();` → Destructor: runs automatically when the object goes out of scope.  
- `void write(const std::string& text);` → Method to write text.  
- `private:` → Members hidden from outside.  
- `std::FILE* f;` → Raw pointer to a C file handle.

---

Now implement it in `src/forge_core/lib/file.cpp`:

```cpp
#include "forge/core/file.hpp"
#include <stdexcept>   // for std::runtime_error

namespace forge::core {

    File::File(const std::string& path, const char* mode) {
        f = std::fopen(path.c_str(), mode);
        if (!f) {
            throw std::runtime_error("Failed to open file: " + path);
        }
    }

    File::~File() {
        if (f) {
            std::fclose(f);
        }
    }

    void File::write(const std::string& text) {
        if (!f) return;
        std::fwrite(text.c_str(), 1, text.size(), f);
    }

}
```

### Line‑by‑line

- `#include "forge/core/file.hpp"` → Pulls in our class declaration.  
- `#include <stdexcept>` → For throwing exceptions.  
- `File::File(...) { ... }` → Constructor definition.  
  - `f = std::fopen(path.c_str(), mode);` → Opens the file. `c_str()` converts `std::string` to C‑style string.  
  - `if (!f)` → If `f` is `nullptr`, opening failed.  
  - `throw std::runtime_error(...)` → Throws an exception with an error message.  
- `File::~File() { ... }` → Destructor definition.  
  - `if (f) std::fclose(f);` → If file is open, close it.  
- `void File::write(...) { ... }` → Writes text.  
  - `if (!f) return;` → Guard: do nothing if file isn’t open.  
  - `std::fwrite(...)` → Writes raw bytes to the file.

**Key idea:** When the `File` object goes out of scope, the destructor runs automatically, closing the file. No leaks.

---

## Step 3: Python Context Manager Equivalent

In `python/forge_cli/file_utils.py`:

```python
from contextlib import contextmanager

@contextmanager
def open_file(path: str, mode: str = "w"):
    """Context manager for safe file handling."""
    f = open(path, mode, encoding="utf-8")
    try:
        yield f
    finally:
        f.close()
```

### Line‑by‑line

- `from contextlib import contextmanager` → Imports a decorator to build context managers.  
- `@contextmanager` → Marks the function as a context manager.  
- `def open_file(path: str, mode: str = "w"):` → Function definition with type hints.  
- `f = open(path, mode, encoding="utf-8")` → Opens the file.  
- `try: yield f` → Hands the file object back to the caller.  
- `finally: f.close()` → Ensures the file is closed, even if an exception occurs.

Usage:

```python
from .file_utils import open_file

with open_file("out.txt") as f:
    f.write("Hello from Python!\n")
```

When the `with` block ends, `f.close()` is called automatically.

---

## Step 4: Binding the C++ Class to Python

Update `bindings/python/forge_core_py.cpp`:

```cpp
#include <pybind11/pybind11.h>
#include <forge/core/file.hpp>

namespace py = pybind11;

PYBIND11_MODULE(forge_core_py, m) {
    py::class_<forge::core::File>(m, "File")
        .def(py::init<const std::string&, const char*>())
        .def("write", &forge::core::File::write);
}
```

### Line‑by‑line

- `py::class_<forge::core::File>(m, "File")` → Exposes the C++ class `File` to Python as `forge_core_py.File`.  
- `.def(py::init<const std::string&, const char*>())` → Exposes the constructor (takes path and mode).  
- `.def("write", &forge::core::File::write)` → Exposes the `write` method.

Now in Python:

```python
import forge_core_py

f = forge_core_py.File("out_cpp.txt", "w")
f.write("Hello from C++!\n")
# When f goes out of scope, destructor closes the file
```

---

## Step 5: CLI Integration

Update `python/forge_cli/main.py`:

```python
elif args.show_file:
    print("=== Writing with C++ File class ===")
    f = forge_core_py.File("out_cpp.txt", "w")
    f.write("Hello from C++ RAII!\n")

    print("=== Writing with Python context manager ===")
    from .file_utils import open_file
    with open_file("out_py.txt") as f:
        f.write("Hello from Python context manager!\n")

    print("Files written: out_cpp.txt, out_py.txt")
```

---

## Reflection & Repetition

- **Echo:** Both C++ RAII and Python `with` ensure cleanup. Different syntax, same philosophy.  
- **Why this matters:** Forge will open many files (G‑code, configs, logs). Safe handling prevents leaks and corruption.  
- **Repetition cue:** We’ll revisit RAII when handling sockets, threads, and locks.  
- **Pitfall:** In Python, forgetting `with` can leave files open until GC runs. In C++, forgetting RAII means leaks or crashes.  

---

## Exercises

1. **Guided:** Modify the C++ `File` class to add a `read_line()` method. Bind it to Python.  
2. **Stretch:** In Python, extend `open_file` to accept a `binary=True` flag and open in binary mode.  
3. **Reflection:** Compare: which feels safer to you right now—RAII in C++ or `with` in Python? Why?  

---

✅ **End of Module 3**  
You now understand lifetimes, destructors, RAII, and Python context managers. This is a cornerstone concept: *resources clean themselves up when their owner goes out of scope*.  

---

Michael, do you want me to **continue straight into Module 4 (C++ containers and Python lists)**, or would you like me to **expand Module 3 further** with
