# Module 4: Containers in C++ vs. Python Lists

**Time**: ~2 hours  
**Goals**:

- Understand what containers are and why they matter.
- Compare Python’s `list` with C++’s `std::vector`, `std::list`, and `std::array`.
- Learn about complexity trade‑offs (speed vs. memory).
- Practice creating, modifying, and iterating containers in C++ and Python.
- Tie it back to Forge: storing G‑code lines, tool offsets, and job queues.

---

## Step 1: Why Containers Matter

Think CNC:

- A **list of tool offsets** → you need random access (jump to tool #5 quickly).
- A **queue of jobs** → you need FIFO (first in, first out).
- A **log of events** → you might only append, rarely remove.

Different containers are optimized for different patterns. In Python, you mostly use `list` for everything. In C++, you choose the right container for the job.

---

## Step 2: Python Refresher

```python
# Python list basics
tools = [10, 20, 30]        # create
tools.append(40)            # add
print(tools[2])             # random access
for t in tools:             # iteration
    print(t)
```

- `append` → adds to the end.
- `tools[2]` → random access (O(1)).
- Iteration is straightforward.

Python hides the complexity: lists are dynamic arrays under the hood.

---

## Step 3: C++ Vector (closest to Python list)

Create `src/forge_core/lib/containers.cpp` and `include/forge/core/containers.hpp`.

### `containers.hpp`

```cpp
#pragma once
#include <vector>
#include <string>

namespace forge::core {
    void demo_vector();
}
```

### `containers.cpp`

```cpp
#include "forge/core/containers.hpp"
#include <iostream>

namespace forge::core {

    void demo_vector() {
        std::vector<int> tools = {10, 20, 30};  // initialize with 3 ints

        tools.push_back(40);  // append like Python's list.append

        std::cout << "tools[2] = " << tools[2] << "\n";  // random access

        std::cout << "Iterating:\n";
        for (int t : tools) {   // range-based for loop
            std::cout << t << "\n";
        }
    }

}
```

### Line‑by‑line

- `#include <vector>` → Brings in `std::vector`.
- `std::vector<int> tools = {10, 20, 30};` → A dynamic array of ints.
- `tools.push_back(40);` → Adds an element at the end.
- `tools[2]` → Random access, just like Python’s `list[2]`.
- `for (int t : tools)` → Range‑based for loop (like Python’s `for t in tools`).

**Key difference:** In C++, you must specify the type (`int`). Python lists can mix types; C++ vectors cannot.

---

## Step 4: Other Containers

### Linked List: `std::list`

```cpp
#include <list>

std::list<int> jobs = {1, 2, 3};
jobs.push_back(4);   // add at end
jobs.push_front(0);  // add at front

for (int j : jobs) {
    std::cout << j << "\n";
}
```

- `std::list` is a **doubly linked list**.
- Fast inserts/removes anywhere, but **slow random access** (no `jobs[2]`).

---

### Fixed Array: `std::array`

```cpp
#include <array>

std::array<int, 3> offsets = {100, 200, 300};
std::cout << offsets[1] << "\n";  // prints 200
```

- `std::array<int, 3>` → Fixed size at compile time.
- Safer than raw arrays, but not resizable.

---

## Step 5: Binding to Python (Optional Demo)

Expose `demo_vector` to Python in `forge_core_py.cpp`:

```cpp
#include <pybind11/pybind11.h>
#include <forge/core/containers.hpp>

namespace py = pybind11;

PYBIND11_MODULE(forge_core_py, m) {
    m.def("demo_vector", &forge::core::demo_vector);
}
```

Now in Python:

```python
import forge_core_py
forge_core_py.demo_vector()
```

Output:

```
tools[2] = 30
Iterating:
10
20
30
40
```

---

## Step 6: Complexity Trade‑offs

- `std::vector` → Fast random access, slow inserts in the middle.
- `std::list` → Fast inserts/removes anywhere, slow random access.
- `std::array` → Fixed size, very fast, but inflexible.

Python’s `list` is basically `std::vector` under the hood.

---

## Reflection & Repetition

- **Echo:** You’ve seen Python `list` → C++ `std::vector`.
- **Why this matters:** Choosing the right container = performance and clarity.
- **Repetition cue:** We’ll revisit containers in Phase 3 (DSA), where we’ll implement stacks, queues, and trees.
- **Pitfall:** Don’t assume `std::list` is always better for inserts—modern CPUs often make `std::vector` faster due to cache locality.

---

## Exercises

1. **Guided:** Modify `demo_vector` to remove the last element (`pop_back`) and print the result.
2. **Stretch:** Write a function `sum_vector` that takes a `std::vector<int>` and returns the sum. Bind it to Python.
3. **Reflection:** Compare: in Python, you can mix types in a list. Why might C++ enforce a single type? What are the trade‑offs?

---

✅ **End of Module 4**  
You now understand C++ containers vs. Python lists, their trade‑offs, and how to use them. This is the foundation for data structures and algorithms.

---

Michael, do you want me to **continue into Module 5 (Algorithms on containers: sorting, searching, iteration patterns)**, or would you like me to **expand Module 4 further** with more repetition (e.g., iterators explained line‑by‑line, memory layout diagrams, or deeper comparison with Python)?
