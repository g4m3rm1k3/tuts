Excellent choice — **Module 4** is where we shift from “writing code that works” to “designing code that scales.”

Up to now, you’ve learned:

- What the compiler and linker do (translation units, symbols, IRs, etc.)
- How modular code is compiled and assembled
- How Git can snapshot our work

Now we’ll move into **software engineering territory** — structuring your C++ project like a professional.

---

# 🧭 **Module 04 — Project Organization, Classes, Namespaces, and Builds**

> 💡 _Goal:_ Learn how to build a maintainable, multi-file, multi-module project with logical architecture — not just working code.

We'll use a CNC-themed example and slowly evolve it into a **mini CAD/CAM backend**, showing how to organize source code, headers, namespaces, and builds.

---

## ⚙️ Step 4.1 — The Purpose of Structure

Structure solves **scale** and **collaboration** problems:

- Prevents circular dependencies.
- Makes compiling faster.
- Allows testing or reusing modules independently.
- Separates public API (headers) from implementation (cpp).

Think of it as the **mechanical blueprint** of your codebase —
each folder and file has a clear role, like tooling and operations in a machine shop.

---

## 📁 Step 4.2 — Folder Hierarchy

We’ll evolve our `CNCProject` from before:

```
CNCProject/
├── include/                 # Public headers
│   ├── cnc/                 # Namespaced submodules
│   │   ├── geometry.h
│   │   └── gcode_reader.h
│   └── cnc.h                # Master include header
│
├── src/                     # Source files (implementations)
│   ├── geometry.cpp
│   └── gcode_reader.cpp
│
├── app/                     # Application entry points (main.cpp, CLI)
│   └── main.cpp
│
├── tests/                   # Unit tests, integration tests
│   └── test_geometry.cpp
│
├── build/                   # Compiled output
│
└── README.md
```

---

## 🧩 Step 4.3 — Namespaces

Namespaces are **the logical folders of code** inside C++.
They:

- Avoid naming conflicts.
- Group related functionality.
- Express module ownership.

Example:

```cpp
namespace cnc {
    namespace geometry {
        struct Point {
            double x, y;
        };
    }
}
```

or using shorthand syntax:

```cpp
namespace cnc::geometry {
    struct Point {
        double x, y;
    };
}
```

Now you can access it with:

```cpp
cnc::geometry::Point p {10, 20};
```

---

## 🧱 Step 4.4 — Building the Core Modules

Let’s create a small **Geometry module** to demonstrate.

### `include/cnc/geometry.h`

```cpp
#ifndef CNC_GEOMETRY_H
#define CNC_GEOMETRY_H

namespace cnc::geometry {

struct Point {
    double x, y;
};

double distance(const Point& a, const Point& b);

}

#endif
```

### `src/geometry.cpp`

```cpp
#include "cnc/geometry.h"
#include <cmath>

namespace cnc::geometry {

double distance(const Point& a, const Point& b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return std::sqrt(dx * dx + dy * dy);
}

}
```

---

## 🧰 Step 4.5 — Using It in the Main Application

### `app/main.cpp`

```cpp
#include "cnc/geometry.h"
#include <iostream>

int main() {
    cnc::geometry::Point a{0, 0};
    cnc::geometry::Point b{3, 4};

    std::cout << "Distance: " << cnc::geometry::distance(a, b) << "\n";
    return 0;
}
```

---

## 🧩 Step 4.6 — Compiling Multi-Folder Projects

### Windows PowerShell

```powershell
g++ app\main.cpp src\geometry.cpp -I include -o build\cnc_app.exe
./build/cnc_app.exe
```

### macOS/Linux

```bash
g++ app/main.cpp src/geometry.cpp -I include -o build/cnc_app
./build/cnc_app
```

✅ Output:

```
Distance: 5
```

---

## 🧠 Step 4.7 — Understanding How the Compiler Sees It

1. The compiler compiles each `.cpp` file separately (each is a **translation unit**).
2. Each `.cpp` file includes the relevant `.h` file.
3. The linker later connects symbols across compiled object files.
4. `-I include` tells the compiler where to look for those headers.

---

## ⚙️ Step 4.8 — The Role of `include/` vs `src/`

| Folder     | Purpose                               | Accessed by   |
| ---------- | ------------------------------------- | ------------- |
| `include/` | Public API headers, visible to others | All modules   |
| `src/`     | Private implementations               | Compiler only |
| `app/`     | Executables                           | End-users     |
| `tests/`   | Automated tests                       | Developers    |

**Guideline:**
If another module needs to _know_ about your function, put it in a header.
If it just _uses_ it, put the implementation in `src/`.

---

## 🧩 Step 4.9 — Master Header

It’s common to make a single “umbrella” header to include all module headers:

### `include/cnc.h`

```cpp
#ifndef CNC_H
#define CNC_H

#include "cnc/geometry.h"
#include "cnc/gcode_reader.h" // future addition

#endif
```

Now your main program can simply do:

```cpp
#include "cnc.h"
```

---

## 🧩 Step 4.10 — Building with Make or PowerShell Functions

We’ll later use CMake, but for now, make it quick:

**Windows PowerShell build function:**

```powershell
function build-cnc {
    g++ app\main.cpp src\geometry.cpp -I include -o build\cnc_app.exe
}
```

Now in PowerShell:

```powershell
build-cnc
```

**macOS/Linux equivalent:**

```bash
build-cnc() { g++ app/main.cpp src/geometry.cpp -I include -o build/cnc_app; }
```

✅ You just wrote your first custom build command — like a mini build system.

---

## 🧩 Step 4.11 — Version Control

Commit your clean project:

```bash
git add .
git commit -m "Organized project structure with geometry module and namespaces"
```

---

## 🧭 Step 4.12 — What You’ve Built

You’ve now constructed a **properly organized, modular C++ project**:

- Logical separation (headers, source, apps)
- Namespaced structure
- Clear compilation flow
- Extendable to new modules

---

## 🧩 Step 4.13 — Next Steps

For the next module, we’ll move into **Module 5: Data Representation & Memory**,
where we’ll dive deep into:

- `struct` vs `class` memory layout
- Stack vs heap allocations
- Copy vs reference semantics
- Constructors, destructors, and RAII (Resource Acquisition Is Initialization)
- Pointers and smart pointers (modern C++)

This will let you _actually understand what’s happening under the hood_ when we start building data structures (linked lists, buffers, etc.) later.

---

Would you like to move straight into **Module 5: Data Representation & Memory**,
or pause for a short **Module 4.5 mini-project** that builds a small reusable “CNC Tool Library” to practice namespaces, classes, and file organization first?
