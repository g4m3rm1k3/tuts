Excellent choice â€” **Module 4** is where we shift from â€œwriting code that worksâ€ to â€œdesigning code that scales.â€

Up to now, youâ€™ve learned:

- What the compiler and linker do (translation units, symbols, IRs, etc.)
- How modular code is compiled and assembled
- How Git can snapshot our work

Now weâ€™ll move into **software engineering territory** â€” structuring your C++ project like a professional.

---

# ğŸ§­ **Module 04 â€” Project Organization, Classes, Namespaces, and Builds**

> ğŸ’¡ _Goal:_ Learn how to build a maintainable, multi-file, multi-module project with logical architecture â€” not just working code.

We'll use a CNC-themed example and slowly evolve it into a **mini CAD/CAM backend**, showing how to organize source code, headers, namespaces, and builds.

---

## âš™ï¸ Step 4.1 â€” The Purpose of Structure

Structure solves **scale** and **collaboration** problems:

- Prevents circular dependencies.
- Makes compiling faster.
- Allows testing or reusing modules independently.
- Separates public API (headers) from implementation (cpp).

Think of it as the **mechanical blueprint** of your codebase â€”
each folder and file has a clear role, like tooling and operations in a machine shop.

---

## ğŸ“ Step 4.2 â€” Folder Hierarchy

Weâ€™ll evolve our `CNCProject` from before:

```
CNCProject/
â”œâ”€â”€ include/                 # Public headers
â”‚   â”œâ”€â”€ cnc/                 # Namespaced submodules
â”‚   â”‚   â”œâ”€â”€ geometry.h
â”‚   â”‚   â””â”€â”€ gcode_reader.h
â”‚   â””â”€â”€ cnc.h                # Master include header
â”‚
â”œâ”€â”€ src/                     # Source files (implementations)
â”‚   â”œâ”€â”€ geometry.cpp
â”‚   â””â”€â”€ gcode_reader.cpp
â”‚
â”œâ”€â”€ app/                     # Application entry points (main.cpp, CLI)
â”‚   â””â”€â”€ main.cpp
â”‚
â”œâ”€â”€ tests/                   # Unit tests, integration tests
â”‚   â””â”€â”€ test_geometry.cpp
â”‚
â”œâ”€â”€ build/                   # Compiled output
â”‚
â””â”€â”€ README.md
```

---

## ğŸ§© Step 4.3 â€” Namespaces

Namespaces are **the logical folders of code** inside C++.
They:

- Avoid naming conflicts.
- Group related functionality.
- Express module ownership.

Example:

```cpp
namespace cnc {
    namespace geometry {
        struct Point {
            double x, y;
        };
    }
}
```

or using shorthand syntax:

```cpp
namespace cnc::geometry {
    struct Point {
        double x, y;
    };
}
```

Now you can access it with:

```cpp
cnc::geometry::Point p {10, 20};
```

---

## ğŸ§± Step 4.4 â€” Building the Core Modules

Letâ€™s create a small **Geometry module** to demonstrate.

### `include/cnc/geometry.h`

```cpp
#ifndef CNC_GEOMETRY_H
#define CNC_GEOMETRY_H

namespace cnc::geometry {

struct Point {
    double x, y;
};

double distance(const Point& a, const Point& b);

}

#endif
```

### `src/geometry.cpp`

```cpp
#include "cnc/geometry.h"
#include <cmath>

namespace cnc::geometry {

double distance(const Point& a, const Point& b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return std::sqrt(dx * dx + dy * dy);
}

}
```

---

## ğŸ§° Step 4.5 â€” Using It in the Main Application

### `app/main.cpp`

```cpp
#include "cnc/geometry.h"
#include <iostream>

int main() {
    cnc::geometry::Point a{0, 0};
    cnc::geometry::Point b{3, 4};

    std::cout << "Distance: " << cnc::geometry::distance(a, b) << "\n";
    return 0;
}
```

---

## ğŸ§© Step 4.6 â€” Compiling Multi-Folder Projects

### Windows PowerShell

```powershell
g++ app\main.cpp src\geometry.cpp -I include -o build\cnc_app.exe
./build/cnc_app.exe
```

### macOS/Linux

```bash
g++ app/main.cpp src/geometry.cpp -I include -o build/cnc_app
./build/cnc_app
```

âœ… Output:

```
Distance: 5
```

---

## ğŸ§  Step 4.7 â€” Understanding How the Compiler Sees It

1. The compiler compiles each `.cpp` file separately (each is a **translation unit**).
2. Each `.cpp` file includes the relevant `.h` file.
3. The linker later connects symbols across compiled object files.
4. `-I include` tells the compiler where to look for those headers.

---

## âš™ï¸ Step 4.8 â€” The Role of `include/` vs `src/`

| Folder     | Purpose                               | Accessed by   |
| ---------- | ------------------------------------- | ------------- |
| `include/` | Public API headers, visible to others | All modules   |
| `src/`     | Private implementations               | Compiler only |
| `app/`     | Executables                           | End-users     |
| `tests/`   | Automated tests                       | Developers    |

**Guideline:**
If another module needs to _know_ about your function, put it in a header.
If it just _uses_ it, put the implementation in `src/`.

---

## ğŸ§© Step 4.9 â€” Master Header

Itâ€™s common to make a single â€œumbrellaâ€ header to include all module headers:

### `include/cnc.h`

```cpp
#ifndef CNC_H
#define CNC_H

#include "cnc/geometry.h"
#include "cnc/gcode_reader.h" // future addition

#endif
```

Now your main program can simply do:

```cpp
#include "cnc.h"
```

---

## ğŸ§© Step 4.10 â€” Building with Make or PowerShell Functions

Weâ€™ll later use CMake, but for now, make it quick:

**Windows PowerShell build function:**

```powershell
function build-cnc {
    g++ app\main.cpp src\geometry.cpp -I include -o build\cnc_app.exe
}
```

Now in PowerShell:

```powershell
build-cnc
```

**macOS/Linux equivalent:**

```bash
build-cnc() { g++ app/main.cpp src/geometry.cpp -I include -o build/cnc_app; }
```

âœ… You just wrote your first custom build command â€” like a mini build system.

---

## ğŸ§© Step 4.11 â€” Version Control

Commit your clean project:

```bash
git add .
git commit -m "Organized project structure with geometry module and namespaces"
```

---

## ğŸ§­ Step 4.12 â€” What Youâ€™ve Built

Youâ€™ve now constructed a **properly organized, modular C++ project**:

- Logical separation (headers, source, apps)
- Namespaced structure
- Clear compilation flow
- Extendable to new modules

---

## ğŸ§© Step 4.13 â€” Next Steps

For the next module, weâ€™ll move into **Module 5: Data Representation & Memory**,
where weâ€™ll dive deep into:

- `struct` vs `class` memory layout
- Stack vs heap allocations
- Copy vs reference semantics
- Constructors, destructors, and RAII (Resource Acquisition Is Initialization)
- Pointers and smart pointers (modern C++)

This will let you _actually understand whatâ€™s happening under the hood_ when we start building data structures (linked lists, buffers, etc.) later.

---

Would you like to move straight into **Module 5: Data Representation & Memory**,
or pause for a short **Module 4.5 mini-project** that builds a small reusable â€œCNC Tool Libraryâ€ to practice namespaces, classes, and file organization first?
