Excellent â€” this is where we really _become_ systems programmers.
Weâ€™re about to uncover **how C++ actually turns your code into a program** â€” and why the compilerâ€“linker model is one of the most fundamental ideas in _all_ programming.

Weâ€™ll do this step by step, in a _live-coding_ style you can follow along with.
Youâ€™ll type small examples, compile, inspect, and understand every moving part.

---

## ğŸ§© **Module 03: The Hidden Machine â€” Compilation, Linking, and Translation Units**

### ğŸ¯ **Goal**

Understand how C++ goes from `.cpp` and `.h` files â†’ to object files â†’ to an executable.
Youâ€™ll learn:

- what the compiler _really_ does,
- how the linker combines pieces,
- what a translation unit is,
- why headers can cause errors like â€œmultiple definitionâ€ or â€œundefined referenceâ€,
- and how to diagnose linking errors like a pro.

---

# ğŸªœ Step 1 â€” One File, One Translation Unit

Letâ€™s start with the simplest possible program.

### `main.cpp`

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, translation unit!\n";
    return 0;
}
```

Now compile and link in one command:

#### On Windows PowerShell

```powershell
g++ main.cpp -o main.exe
./main.exe
```

#### On macOS or Linux

```bash
g++ main.cpp -o main
./main
```

âœ… **Output**

```
Hello, translation unit!
```

**What just happened:**

- The compiler (`g++`) read `main.cpp`, parsed it, and generated a _translation unit_ â€” basically, the preprocessed source file (after includes/macros are expanded).
- Then it compiled that translation unit into an **object file** (`main.o` or `main.obj` on Windows).
- Finally, the linker took that object file and produced the final executable.

---

# ğŸ§± Step 2 â€” Splitting Code Across Files

Now weâ€™ll separate logic and declarations to simulate a real project.

### `math_utils.h`

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);

#endif
```

### `math_utils.cpp`

```cpp
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}
```

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "2 + 3 = " << add(2, 3) << "\n";
}
```

Now compile them _together_:

#### PowerShell

```powershell
g++ main.cpp math_utils.cpp -o app.exe
./app.exe
```

#### macOS/Linux

```bash
g++ main.cpp math_utils.cpp -o app
./app
```

âœ… **Output**

```
2 + 3 = 5
```

---

## ğŸ§  Whatâ€™s Going On

Each `.cpp` file is compiled **independently** into an object file.

Visually:

```
 math_utils.cpp â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”œâ”€â”€â–¶   â”‚ math_utils.o â”‚
 main.cpp â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚ Linker â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚  app   â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

When you run `g++ main.cpp math_utils.cpp`, the compiler:

1. Compiles **each** `.cpp` file â†’ `.o` (object file).
2. Invokes the **linker**, which:

   - Merges all object files.
   - Resolves _symbol references_ (function and variable names).
   - Produces a final executable.

---

# ğŸ” Step 3 â€” See the Intermediate Files

Letâ€™s view whatâ€™s actually created.

### PowerShell

```powershell
g++ -c main.cpp
g++ -c math_utils.cpp
```

This creates:

```
main.obj
math_utils.obj
```

Now link them manually:

```powershell
g++ main.obj math_utils.obj -o app.exe
```

âœ… Run:

```powershell
./app.exe
```

This manual split helps you understand the two stages:

- **Compile stage** (`-c`): turns `.cpp` â†’ `.obj`
- **Link stage**: turns `.obj` â†’ `.exe`

---

# ğŸ” Step 4 â€” Exploring Headers and Preprocessing

Letâ€™s see what `#include` actually does.

Use this:

```powershell
g++ -E main.cpp > preprocessed.cpp
```

Open `preprocessed.cpp`.
Youâ€™ll see that all `#include` files are _literally pasted in_ â€” thousands of lines from `<iostream>` appear at the top.

Thatâ€™s why:

- Headers must be guarded with `#ifndef ... #define ... #endif`
- Otherwise, if the same header is included twice, the compiler sees two copies of the same declarations.

---

# âš™ï¸ Step 5 â€” Symbol Resolution and Linker Errors

Letâ€™s _intentionally_ break it.

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "Sum: " << add(2, 3) << "\n";
}
```

### `math_utils.h`

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);
int subtract(int a, int b); // declared but not defined!

#endif
```

Now compile both:

```bash
g++ main.cpp math_utils.cpp -o app
```

âš ï¸ **Linker error:**

```
undefined reference to `subtract(int, int)'
```

### Why:

- The compiler didnâ€™t complain â€” both files compiled fine.
- The linker failed, because it could not _find_ any definition of `subtract`.

Thatâ€™s how symbol resolution works â€” all declared names must be defined in some object file (or a linked library).

---

# ğŸ§© Step 6 â€” Multiple Definition Error

Now define `add()` twice, once in `math_utils.cpp` and once in `main.cpp`:

```cpp
int add(int a, int b) { return a + b; }
```

âš ï¸ Linker error:

```
multiple definition of `add(int, int)'
```

Each translation unit compiled separately defines the same symbol â€” the linker detects the conflict.

âœ… **Rule:**
A function or variable should have exactly **one definition**, but may have many **declarations**.

---

# ğŸ”© Step 7 â€” Using `static` and `inline` to Control Visibility

- `static` (in a global context) limits the function to the current translation unit.
- `inline` allows multiple identical definitions across files.

### Example

**`math_utils.h`**

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

inline int multiply(int a, int b) { return a * b; }

#endif
```

This is safe to include in many files â€” each copy will compile its own inline version.

---

# ğŸ§  Step 8 â€” Object Files and Symbols

To inspect whatâ€™s inside object files:

#### macOS/Linux

```bash
nm math_utils.o
```

#### Windows (MinGW)

```powershell
nm math_utils.obj
```

Youâ€™ll see symbol tables â€” e.g. `_Z3addii` (mangled name of `add(int,int)`).

This is how the linker matches references between object files.

---

# ğŸ§± Step 9 â€” Build Automation

Instead of typing `g++` manually, use **Make** (or later, CMake).

Create a simple `Makefile`:

```makefile
app: main.o math_utils.o
	g++ main.o math_utils.o -o app

main.o: main.cpp math_utils.h
	g++ -c main.cpp

math_utils.o: math_utils.cpp math_utils.h
	g++ -c math_utils.cpp

clean:
	rm -f *.o app
```

Then:

```bash
make
./app
```

This introduces **build systems**, which track dependencies and rebuild only what changed.

---

# ğŸ”­ Step 10 â€” Mental Model Summary

| Stage | Tool         | Input                 | Output          | Role                                   |
| ----- | ------------ | --------------------- | --------------- | -------------------------------------- |
| 1     | Preprocessor | `.cpp`                | expanded source | Expands `#include`, macros             |
| 2     | Compiler     | expanded source       | `.o` / `.obj`   | Translates C++ â†’ machine code          |
| 3     | Linker       | `.o` files, libraries | `.exe`          | Combines all code and resolves symbols |

---

# ğŸ§© Step 11 â€” Exercises

1. Create another `.cpp` file with a new function and link it in.
2. Intentionally create multiple definitions and fix them.
3. Use `nm` to list symbols and identify which file defines what.
4. Add a global variable to test how the linker handles duplicate globals.

---

# ğŸ§­ Coming Next

In **Module 04**, weâ€™ll introduce **namespaces, classes, and compilation boundaries** â€” and begin structuring a proper **C++ project** with folders and build systems.

Weâ€™ll also start designing our long-term **C++ project** that weâ€™ll later integrate with **Python (via pybind11)**.

---

Would you like me to continue by:

1. Adding **practical compiler inspection** commands (e.g., view assembly, symbol mangling, intermediate representations),
2. Or move straight to **Module 04: Organizing a real C++ project** (headers, classes, namespaces)?
