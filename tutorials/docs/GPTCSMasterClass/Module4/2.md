Excellent — this is where we really _become_ systems programmers.
We’re about to uncover **how C++ actually turns your code into a program** — and why the compiler–linker model is one of the most fundamental ideas in _all_ programming.

We’ll do this step by step, in a _live-coding_ style you can follow along with.
You’ll type small examples, compile, inspect, and understand every moving part.

---

## 🧩 **Module 03: The Hidden Machine — Compilation, Linking, and Translation Units**

### 🎯 **Goal**

Understand how C++ goes from `.cpp` and `.h` files → to object files → to an executable.
You’ll learn:

- what the compiler _really_ does,
- how the linker combines pieces,
- what a translation unit is,
- why headers can cause errors like “multiple definition” or “undefined reference”,
- and how to diagnose linking errors like a pro.

---

# 🪜 Step 1 — One File, One Translation Unit

Let’s start with the simplest possible program.

### `main.cpp`

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, translation unit!\n";
    return 0;
}
```

Now compile and link in one command:

#### On Windows PowerShell

```powershell
g++ main.cpp -o main.exe
./main.exe
```

#### On macOS or Linux

```bash
g++ main.cpp -o main
./main
```

✅ **Output**

```
Hello, translation unit!
```

**What just happened:**

- The compiler (`g++`) read `main.cpp`, parsed it, and generated a _translation unit_ — basically, the preprocessed source file (after includes/macros are expanded).
- Then it compiled that translation unit into an **object file** (`main.o` or `main.obj` on Windows).
- Finally, the linker took that object file and produced the final executable.

---

# 🧱 Step 2 — Splitting Code Across Files

Now we’ll separate logic and declarations to simulate a real project.

### `math_utils.h`

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);

#endif
```

### `math_utils.cpp`

```cpp
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}
```

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "2 + 3 = " << add(2, 3) << "\n";
}
```

Now compile them _together_:

#### PowerShell

```powershell
g++ main.cpp math_utils.cpp -o app.exe
./app.exe
```

#### macOS/Linux

```bash
g++ main.cpp math_utils.cpp -o app
./app
```

✅ **Output**

```
2 + 3 = 5
```

---

## 🧠 What’s Going On

Each `.cpp` file is compiled **independently** into an object file.

Visually:

```
 math_utils.cpp ─┐      ┌──────────────┐
                 ├──▶   │ math_utils.o │
 main.cpp ───────┘      └──────────────┘
                           │
                           ▼
                       ┌────────┐
                       │ Linker │
                       └────────┘
                           │
                           ▼
                       ┌────────┐
                       │  app   │
                       └────────┘
```

When you run `g++ main.cpp math_utils.cpp`, the compiler:

1. Compiles **each** `.cpp` file → `.o` (object file).
2. Invokes the **linker**, which:

   - Merges all object files.
   - Resolves _symbol references_ (function and variable names).
   - Produces a final executable.

---

# 🔍 Step 3 — See the Intermediate Files

Let’s view what’s actually created.

### PowerShell

```powershell
g++ -c main.cpp
g++ -c math_utils.cpp
```

This creates:

```
main.obj
math_utils.obj
```

Now link them manually:

```powershell
g++ main.obj math_utils.obj -o app.exe
```

✅ Run:

```powershell
./app.exe
```

This manual split helps you understand the two stages:

- **Compile stage** (`-c`): turns `.cpp` → `.obj`
- **Link stage**: turns `.obj` → `.exe`

---

# 🔎 Step 4 — Exploring Headers and Preprocessing

Let’s see what `#include` actually does.

Use this:

```powershell
g++ -E main.cpp > preprocessed.cpp
```

Open `preprocessed.cpp`.
You’ll see that all `#include` files are _literally pasted in_ — thousands of lines from `<iostream>` appear at the top.

That’s why:

- Headers must be guarded with `#ifndef ... #define ... #endif`
- Otherwise, if the same header is included twice, the compiler sees two copies of the same declarations.

---

# ⚙️ Step 5 — Symbol Resolution and Linker Errors

Let’s _intentionally_ break it.

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "Sum: " << add(2, 3) << "\n";
}
```

### `math_utils.h`

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);
int subtract(int a, int b); // declared but not defined!

#endif
```

Now compile both:

```bash
g++ main.cpp math_utils.cpp -o app
```

⚠️ **Linker error:**

```
undefined reference to `subtract(int, int)'
```

### Why:

- The compiler didn’t complain — both files compiled fine.
- The linker failed, because it could not _find_ any definition of `subtract`.

That’s how symbol resolution works — all declared names must be defined in some object file (or a linked library).

---

# 🧩 Step 6 — Multiple Definition Error

Now define `add()` twice, once in `math_utils.cpp` and once in `main.cpp`:

```cpp
int add(int a, int b) { return a + b; }
```

⚠️ Linker error:

```
multiple definition of `add(int, int)'
```

Each translation unit compiled separately defines the same symbol — the linker detects the conflict.

✅ **Rule:**
A function or variable should have exactly **one definition**, but may have many **declarations**.

---

# 🔩 Step 7 — Using `static` and `inline` to Control Visibility

- `static` (in a global context) limits the function to the current translation unit.
- `inline` allows multiple identical definitions across files.

### Example

**`math_utils.h`**

```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

inline int multiply(int a, int b) { return a * b; }

#endif
```

This is safe to include in many files — each copy will compile its own inline version.

---

# 🧠 Step 8 — Object Files and Symbols

To inspect what’s inside object files:

#### macOS/Linux

```bash
nm math_utils.o
```

#### Windows (MinGW)

```powershell
nm math_utils.obj
```

You’ll see symbol tables — e.g. `_Z3addii` (mangled name of `add(int,int)`).

This is how the linker matches references between object files.

---

# 🧱 Step 9 — Build Automation

Instead of typing `g++` manually, use **Make** (or later, CMake).

Create a simple `Makefile`:

```makefile
app: main.o math_utils.o
	g++ main.o math_utils.o -o app

main.o: main.cpp math_utils.h
	g++ -c main.cpp

math_utils.o: math_utils.cpp math_utils.h
	g++ -c math_utils.cpp

clean:
	rm -f *.o app
```

Then:

```bash
make
./app
```

This introduces **build systems**, which track dependencies and rebuild only what changed.

---

# 🔭 Step 10 — Mental Model Summary

| Stage | Tool         | Input                 | Output          | Role                                   |
| ----- | ------------ | --------------------- | --------------- | -------------------------------------- |
| 1     | Preprocessor | `.cpp`                | expanded source | Expands `#include`, macros             |
| 2     | Compiler     | expanded source       | `.o` / `.obj`   | Translates C++ → machine code          |
| 3     | Linker       | `.o` files, libraries | `.exe`          | Combines all code and resolves symbols |

---

# 🧩 Step 11 — Exercises

1. Create another `.cpp` file with a new function and link it in.
2. Intentionally create multiple definitions and fix them.
3. Use `nm` to list symbols and identify which file defines what.
4. Add a global variable to test how the linker handles duplicate globals.

---

# 🧭 Coming Next

In **Module 04**, we’ll introduce **namespaces, classes, and compilation boundaries** — and begin structuring a proper **C++ project** with folders and build systems.

We’ll also start designing our long-term **C++ project** that we’ll later integrate with **Python (via pybind11)**.

---

Would you like me to continue by:

1. Adding **practical compiler inspection** commands (e.g., view assembly, symbol mangling, intermediate representations),
2. Or move straight to **Module 04: Organizing a real C++ project** (headers, classes, namespaces)?
