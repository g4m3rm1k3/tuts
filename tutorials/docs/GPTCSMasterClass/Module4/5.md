Perfect ‚Äî **Module 4.5: CNC Tool Library Mini-Project** will be our first _hands-on engineering system_ inside the C++ masterclass.
It‚Äôs not just a demo ‚Äî this will evolve across future modules to connect with **Python**, **databases**, and **UI tools** later.
We‚Äôll start small and build up, while explaining _why_ each design choice matters.

---

## üß≠ Goal

Build a **modular, reusable C++ library** called `cnc_tool_lib` that:

- Models CNC tools (e.g., end mills, drills, etc.)
- Stores them in a collection
- Lets us search, add, or list them
- Is organized with **namespaces, headers, source files, and build config**
- Compiles cleanly with **g++ or clang++**
- Scales up later to link into Python (via pybind11)

---

## üìÅ Step 0 ‚Äì Folder Layout

We‚Äôll use a **classic C++ project structure**:

```
CNC_Tool_Library/
‚îÇ
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ cnc/
‚îÇ       ‚îî‚îÄ‚îÄ tool.hpp          # Public header
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ tool.cpp              # Implementation
‚îÇ
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ main.cpp              # Test the library
‚îÇ
‚îî‚îÄ‚îÄ Makefile                  # Build system (simple)
```

> üß† **Why this structure?**
>
> - `/include` ‚Üí Public headers (what other code imports)
> - `/src` ‚Üí Internal .cpp source files
> - `/examples` ‚Üí Demos / tests
> - `Makefile` ‚Üí Simple automation for building everything

Let‚Äôs build this incrementally.

---

## üß© Step 1 ‚Äì The Tool Class Header (`include/cnc/tool.hpp`)

Create this file:

```cpp
#ifndef CNC_TOOL_HPP
#define CNC_TOOL_HPP

#include <string>
#include <iostream>

namespace cnc {

class Tool {
private:
    int id;
    std::string name;
    double diameter;
    double length;

public:
    Tool(int id, std::string name, double diameter, double length);

    // Getters
    int getId() const;
    std::string getName() const;
    double getDiameter() const;
    double getLength() const;

    // Setters
    void setName(const std::string& newName);
    void setDiameter(double newDiameter);
    void setLength(double newLength);

    // Display function
    void print() const;
};

} // namespace cnc

#endif
```

> ‚öôÔ∏è **Concepts Introduced:**
>
> - `#ifndef / #define / #endif` ‚Üí _Header guards_ (prevents double inclusion)
> - `namespace cnc {}` ‚Üí groups your code; avoids naming collisions
> - Only **declarations** ‚Äî no implementation logic yet
> - Member functions use `const` to promise ‚ÄúI don‚Äôt modify this object‚Äù

---

## ‚öôÔ∏è Step 2 ‚Äì Implementation File (`src/tool.cpp`)

```cpp
#include "cnc/tool.hpp"

namespace cnc {

Tool::Tool(int id, std::string name, double diameter, double length)
    : id(id), name(std::move(name)), diameter(diameter), length(length) {}

int Tool::getId() const { return id; }
std::string Tool::getName() const { return name; }
double Tool::getDiameter() const { return diameter; }
double Tool::getLength() const { return length; }

void Tool::setName(const std::string& newName) { name = newName; }
void Tool::setDiameter(double newDiameter) { diameter = newDiameter; }
void Tool::setLength(double newLength) { length = newLength; }

void Tool::print() const {
    std::cout << "Tool[" << id << "] "
              << name << " | √ò" << diameter
              << " | L=" << length << "\n";
}

} // namespace cnc
```

> üß† **Concepts Introduced:**
>
> - `::` = _scope resolution operator_ ‚Äî tells compiler that we‚Äôre defining `Tool` functions in the `cnc` namespace.
> - `std::move()` = efficiently transfer ownership of a string (performance habit).
> - Splitting declaration (header) and definition (source) is crucial for clean builds.

---

## üßÆ Step 3 ‚Äì Main Program to Test (`examples/main.cpp`)

```cpp
#include "cnc/tool.hpp"
#include <vector>

int main() {
    std::vector<cnc::Tool> tools;

    tools.emplace_back(1, "Flat End Mill", 0.25, 2.0);
    tools.emplace_back(2, "Ball Nose", 0.5, 3.0);
    tools.emplace_back(3, "Drill Bit", 0.125, 1.5);

    for (const auto& t : tools) {
        t.print();
    }
}
```

> ‚úÖ Uses `std::vector` to manage a dynamic list of `Tool` objects.
> Each `.emplace_back()` constructs an object directly in place.

---

## üß± Step 4 ‚Äì Simple Makefile

Create `Makefile` in root:

```makefile
CXX = g++
CXXFLAGS = -std=c++17 -Iinclude -Wall -Wextra

SRC = $(wildcard src/*.cpp)
OBJ = $(SRC:.cpp=.o)

example: $(OBJ) examples/main.cpp
	$(CXX) $(CXXFLAGS) -o $@ $^

clean:
	rm -f src/*.o example
```

Run this from the project root:

```bash
make
./example
```

Expected output:

```
Tool[1] Flat End Mill | √ò0.25 | L=2
Tool[2] Ball Nose | √ò0.5 | L=3
Tool[3] Drill Bit | √ò0.125 | L=1.5
```

---

## üîç Step 5 ‚Äì Inspecting Compiler Stages (Optional but Deep)

Let‚Äôs see what the compiler does internally.

### See Preprocessed Output

```bash
g++ -E examples/main.cpp | less
```

Shows code _after_ all includes and macros ‚Äî a single massive ‚Äútranslation unit‚Äù.

### See Object Code (before linking)

```bash
g++ -c src/tool.cpp -o tool.o
nm tool.o
```

`nm` lists _symbols_ (function and variable names) ‚Äî this is how the linker knows what to connect.

### See Assembly Output

```bash
g++ -S examples/main.cpp -o main.s
less main.s
```

Now you can inspect how C++ turns into machine instructions.

---

## üß† Summary of Concepts Covered

| Concept                              | Description                  |
| ------------------------------------ | ---------------------------- |
| Header Guards                        | Prevent multiple inclusion   |
| Namespaces                           | Logical grouping & isolation |
| Header / Source Split                | Enables modular compilation  |
| Constructors / Methods               | Core OOP structure           |
| Vector Storage                       | Dynamic memory management    |
| Makefile                             | Automation & reproducibility |
| Preprocessor / Object File / Linking | Build pipeline insight       |

---

## üî≠ Next Mini-Project Step

We‚Äôll expand this into a **ToolManager** class with:

- A searchable collection (by name, diameter)
- File load/save (JSON or CSV)
- Static methods and factories
- Namespaces split by purpose (e.g., `cnc::io`, `cnc::model`)

Then we‚Äôll use this project to:

- Demonstrate **linking against a library**
- Expose C++ to **Python (pybind11)**
- Eventually compile it to **WebAssembly**

---

Would you like to continue by adding the **ToolManager** class (Module 4.6) ‚Äî where we manage collections and introduce static factory methods, file I/O, and modular linking?
