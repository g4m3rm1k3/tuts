Perfect â€” this is the right next step.
This is where you go from _â€œI can compile codeâ€_ â†’ _â€œI understand what the compiler does under the hood.â€_

Weâ€™ll **look inside the compilerâ€™s pipeline** with practical, runnable examples:

- **Preprocessing** (`-E`)
- **Compilation â†’ Assembly** (`-S`)
- **Object code** (`-c`)
- **Disassembly & symbols** (`objdump`, `nm`, `c++filt`)
- **Intermediate representations** (`-fdump-tree-*`)

Youâ€™ll learn how to watch your C++ get transformed â€” step by step.

---

# ğŸ§© **Module 03.2 â€” Seeing the Compilerâ€™s Mind**

Weâ€™ll continue with the same files from before.

### ğŸ“ Files

```
main.cpp
math_utils.cpp
math_utils.h
```

---

## ğŸªœ Step 1 â€” Preprocessing

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "2 + 3 = " << add(2, 3) << "\n";
}
```

### Command (Windows PowerShell or macOS/Linux)

```bash
g++ -E main.cpp > main_preprocessed.cpp
```

Now open `main_preprocessed.cpp`.

ğŸ” **What youâ€™ll see:**

- Every `#include` replaced with actual code.
- No comments.
- Every macro expanded.

â¡ï¸ This is the **translation unit** before compilation.
Itâ€™s what the compiler _actually_ reads.

ğŸ“š **Resource:**

- [GCC Preprocessing Explained](https://gcc.gnu.org/onlinedocs/cpp/)
- [cppreference: Translation Phase](https://en.cppreference.com/w/cpp/language/translation_phases)

---

## ğŸ§© Step 2 â€” Compilation to Assembly

Letâ€™s stop before linking and view the **assembly code**.

```bash
g++ -S main.cpp -o main.s
```

Open `main.s` (plain text file).

Youâ€™ll see something like:

```asm
	.file	"main.cpp"
	.text
	.globl	_main
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	...
	call	__Z3addii
```

ğŸ” **Meaning:**

- Each function in your C++ code turns into assembly instructions.
- `call __Z3addii` calls `add(int,int)` (the name is _mangled_ â€” weâ€™ll decode that soon).

ğŸ“š **Resource:**

- [Learn x86-64 Assembly by Example](https://cs.lmu.edu/~ray/notes/x86assembly/)
- [Compiler Explorer (view live assembly)](https://godbolt.org)

---

## ğŸ§± Step 3 â€” Compilation to Object Code

```bash
g++ -c main.cpp
```

Now youâ€™ll have `main.o` (or `main.obj`).

This file is binary â€” not human-readable â€” but you can **inspect it**.

---

## ğŸ” Step 4 â€” List Symbols (Functions, Variables)

Use `nm` to see what functions or variables are defined or referenced in the object file.

### Windows (with MinGW)

```powershell
nm main.obj
```

### macOS/Linux

```bash
nm main.o
```

Youâ€™ll see output like:

```
U __Z3addii
T main
```

- `U` â†’ _undefined_ (this file **uses** it)
- `T` â†’ _text section_ (this file **defines** it)

So `main` is defined here, but `__Z3addii` is undefined â€” it will be provided by another object (`math_utils.o`).

---

## ğŸ§  Step 5 â€” Name Mangling and Demangling

C++ supports **function overloading**, so `add(int,int)` and `add(float,float)` need unique symbols.
The compiler encodes (or â€œmanglesâ€) them:

- `add(int,int)` â†’ `_Z3addii`
- `add(float,float)` â†’ `_Z3addff`

To decode (demangle):

### Example

```bash
nm main.o | c++filt
```

Output:

```
U add(int, int)
T main
```

âœ… **Now you can read symbols!**

ğŸ“š **Resource:**

- [Itanium C++ ABI: Name Mangling Rules](https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling)

---

## ğŸ”© Step 6 â€” Disassembling the Object File

See actual machine instructions:

```bash
objdump -d main.o
```

Output (simplified):

```asm
0000000000000000 <main>:
   0: 55                    push   %rbp
   1: 48 89 e5              mov    %rsp,%rbp
   4: e8 00 00 00 00        call   9 <add(int,int)>
   ...
```

Youâ€™re now reading what your CPU will execute.
Every instruction corresponds to the compiled version of your C++ code.

ğŸ“š **Resource:**

- [GNU objdump Manual](https://sourceware.org/binutils/docs/binutils/objdump.html)

---

## ğŸ§¬ Step 7 â€” Intermediate Representations (GCC Trees)

GCC lets you dump internal representations used for optimization.

Try this:

```bash
g++ -fdump-tree-all main.cpp
```

This creates many files like:

```
main.cpp.001t.tu
main.cpp.002t.parse
main.cpp.003t.original
...
```

Each one is an **internal view** of the code at a stage of transformation:

- `tu` â†’ translation unit
- `gimple` â†’ simplified three-address code used for optimization
- `optimized` â†’ post-optimization form

These are advanced but fascinating for compiler study.

ğŸ“š **Resources:**

- [GCC Internals Manual](https://gcc.gnu.org/onlinedocs/gccint/)
- [GIMPLE Overview (GCC Wiki)](https://gcc.gnu.org/wiki/GIMPLE)

---

## ğŸ§© Step 8 â€” Inspect Linking Stage

After compiling both `.o` files:

```bash
g++ -c main.cpp
g++ -c math_utils.cpp
```

Link them:

```bash
g++ main.o math_utils.o -o app
```

Inspect the final executable:

```bash
nm app | c++filt
```

Now both `main` and `add(int,int)` appear as **defined**.

---

## ğŸ§  Step 9 â€” Visual Summary

| Stage         | Command  | Output          | Inspect Tool               |
| ------------- | -------- | --------------- | -------------------------- |
| Preprocessing | `g++ -E` | `.i` or `.cpp`  | text editor                |
| Compilation   | `g++ -S` | `.s`            | text editor                |
| Object code   | `g++ -c` | `.o`            | `nm`, `objdump`, `c++filt` |
| Linking       | `g++`    | `.exe` / `.out` | `nm`, `strings`, `objdump` |

---

## ğŸ§­ Step 10 â€” Exercises

Try these small explorations:

1. Create a second overloaded `add(float,float)` â€” inspect the different mangled names.
2. Compile with `-O0`, `-O2`, and compare assembly output (youâ€™ll see inlining, loop changes, etc.).
3. Use `objdump -d -M intel` to see Intel-style assembly syntax.
4. Run `strings app` to view readable strings inside your binary.

---

## ğŸ§© What You Now Know

Youâ€™ve seen:

- How the compiler transforms C++ step by step.
- How to peek into each stage.
- How linking and symbol resolution work.
- How to interpret and demangle symbols.
- How to inspect optimized assembly and IRs.

Youâ€™ve gone from _â€œblack box compileâ€_ â†’ _â€œunderstanding every layer.â€_

---

Would you like to continue next with:

1. **Module 04 â€“ Project Organization** (folders, classes, namespaces, builds),
2. Or take a **short detour into compiler optimizations** (what `-O1/-O2/-O3` actually do and how to measure their effects)?
