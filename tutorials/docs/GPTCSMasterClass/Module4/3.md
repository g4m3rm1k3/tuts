Perfect — this is the right next step.
This is where you go from _“I can compile code”_ → _“I understand what the compiler does under the hood.”_

We’ll **look inside the compiler’s pipeline** with practical, runnable examples:

- **Preprocessing** (`-E`)
- **Compilation → Assembly** (`-S`)
- **Object code** (`-c`)
- **Disassembly & symbols** (`objdump`, `nm`, `c++filt`)
- **Intermediate representations** (`-fdump-tree-*`)

You’ll learn how to watch your C++ get transformed — step by step.

---

# 🧩 **Module 03.2 — Seeing the Compiler’s Mind**

We’ll continue with the same files from before.

### 📁 Files

```
main.cpp
math_utils.cpp
math_utils.h
```

---

## 🪜 Step 1 — Preprocessing

### `main.cpp`

```cpp
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << "2 + 3 = " << add(2, 3) << "\n";
}
```

### Command (Windows PowerShell or macOS/Linux)

```bash
g++ -E main.cpp > main_preprocessed.cpp
```

Now open `main_preprocessed.cpp`.

🔍 **What you’ll see:**

- Every `#include` replaced with actual code.
- No comments.
- Every macro expanded.

➡️ This is the **translation unit** before compilation.
It’s what the compiler _actually_ reads.

📚 **Resource:**

- [GCC Preprocessing Explained](https://gcc.gnu.org/onlinedocs/cpp/)
- [cppreference: Translation Phase](https://en.cppreference.com/w/cpp/language/translation_phases)

---

## 🧩 Step 2 — Compilation to Assembly

Let’s stop before linking and view the **assembly code**.

```bash
g++ -S main.cpp -o main.s
```

Open `main.s` (plain text file).

You’ll see something like:

```asm
	.file	"main.cpp"
	.text
	.globl	_main
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	...
	call	__Z3addii
```

🔍 **Meaning:**

- Each function in your C++ code turns into assembly instructions.
- `call __Z3addii` calls `add(int,int)` (the name is _mangled_ — we’ll decode that soon).

📚 **Resource:**

- [Learn x86-64 Assembly by Example](https://cs.lmu.edu/~ray/notes/x86assembly/)
- [Compiler Explorer (view live assembly)](https://godbolt.org)

---

## 🧱 Step 3 — Compilation to Object Code

```bash
g++ -c main.cpp
```

Now you’ll have `main.o` (or `main.obj`).

This file is binary — not human-readable — but you can **inspect it**.

---

## 🔍 Step 4 — List Symbols (Functions, Variables)

Use `nm` to see what functions or variables are defined or referenced in the object file.

### Windows (with MinGW)

```powershell
nm main.obj
```

### macOS/Linux

```bash
nm main.o
```

You’ll see output like:

```
U __Z3addii
T main
```

- `U` → _undefined_ (this file **uses** it)
- `T` → _text section_ (this file **defines** it)

So `main` is defined here, but `__Z3addii` is undefined — it will be provided by another object (`math_utils.o`).

---

## 🧠 Step 5 — Name Mangling and Demangling

C++ supports **function overloading**, so `add(int,int)` and `add(float,float)` need unique symbols.
The compiler encodes (or “mangles”) them:

- `add(int,int)` → `_Z3addii`
- `add(float,float)` → `_Z3addff`

To decode (demangle):

### Example

```bash
nm main.o | c++filt
```

Output:

```
U add(int, int)
T main
```

✅ **Now you can read symbols!**

📚 **Resource:**

- [Itanium C++ ABI: Name Mangling Rules](https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling)

---

## 🔩 Step 6 — Disassembling the Object File

See actual machine instructions:

```bash
objdump -d main.o
```

Output (simplified):

```asm
0000000000000000 <main>:
   0: 55                    push   %rbp
   1: 48 89 e5              mov    %rsp,%rbp
   4: e8 00 00 00 00        call   9 <add(int,int)>
   ...
```

You’re now reading what your CPU will execute.
Every instruction corresponds to the compiled version of your C++ code.

📚 **Resource:**

- [GNU objdump Manual](https://sourceware.org/binutils/docs/binutils/objdump.html)

---

## 🧬 Step 7 — Intermediate Representations (GCC Trees)

GCC lets you dump internal representations used for optimization.

Try this:

```bash
g++ -fdump-tree-all main.cpp
```

This creates many files like:

```
main.cpp.001t.tu
main.cpp.002t.parse
main.cpp.003t.original
...
```

Each one is an **internal view** of the code at a stage of transformation:

- `tu` → translation unit
- `gimple` → simplified three-address code used for optimization
- `optimized` → post-optimization form

These are advanced but fascinating for compiler study.

📚 **Resources:**

- [GCC Internals Manual](https://gcc.gnu.org/onlinedocs/gccint/)
- [GIMPLE Overview (GCC Wiki)](https://gcc.gnu.org/wiki/GIMPLE)

---

## 🧩 Step 8 — Inspect Linking Stage

After compiling both `.o` files:

```bash
g++ -c main.cpp
g++ -c math_utils.cpp
```

Link them:

```bash
g++ main.o math_utils.o -o app
```

Inspect the final executable:

```bash
nm app | c++filt
```

Now both `main` and `add(int,int)` appear as **defined**.

---

## 🧠 Step 9 — Visual Summary

| Stage         | Command  | Output          | Inspect Tool               |
| ------------- | -------- | --------------- | -------------------------- |
| Preprocessing | `g++ -E` | `.i` or `.cpp`  | text editor                |
| Compilation   | `g++ -S` | `.s`            | text editor                |
| Object code   | `g++ -c` | `.o`            | `nm`, `objdump`, `c++filt` |
| Linking       | `g++`    | `.exe` / `.out` | `nm`, `strings`, `objdump` |

---

## 🧭 Step 10 — Exercises

Try these small explorations:

1. Create a second overloaded `add(float,float)` — inspect the different mangled names.
2. Compile with `-O0`, `-O2`, and compare assembly output (you’ll see inlining, loop changes, etc.).
3. Use `objdump -d -M intel` to see Intel-style assembly syntax.
4. Run `strings app` to view readable strings inside your binary.

---

## 🧩 What You Now Know

You’ve seen:

- How the compiler transforms C++ step by step.
- How to peek into each stage.
- How linking and symbol resolution work.
- How to interpret and demangle symbols.
- How to inspect optimized assembly and IRs.

You’ve gone from _“black box compile”_ → _“understanding every layer.”_

---

Would you like to continue next with:

1. **Module 04 – Project Organization** (folders, classes, namespaces, builds),
2. Or take a **short detour into compiler optimizations** (what `-O1/-O2/-O3` actually do and how to measure their effects)?
