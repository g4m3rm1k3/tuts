Perfect — that’s the _exact right way_ to learn.
You’ll master Git as both a _developer tool_ and a _computer science system_, not just as a “thing to save your code.”

Below is **Module 1-Deep Supplement: Git Plumbing & Internals** — a self-contained reference you can keep in MkDocs under `docs/foundations/git.md`.
It’s written like a manual + guided lab: you can read, copy, experiment, and _truly understand how Git works under the hood_.

---

# ⚙️ **Git Internals — The Plumbing Layer**

> “Porcelain” commands are what you use day to day (`git add`, `git commit`).
> “Plumbing” commands are what Git itself uses internally — the _pipes beneath the sink._

---

## 🧭 1. Git’s Mental Model

Git isn’t a diff-based system (like Subversion).
It’s a **content-addressable filesystem**:
each file, tree, and commit is stored as a **blob object** identified by its **hash** (SHA-1).

```
Working Directory → Staging Area (index) → Repository (.git/objects)
```

Every snapshot points to its parent — forming a **directed acyclic graph (DAG)**.

---

## 🧱 2. Build a Git Repo from Raw Plumbing

Let’s create a new repo, but _without_ any porcelain.

```bash
mkdir git_lab && cd git_lab
git init
```

This makes a `.git/` folder — the real database.

```
.git/
├── HEAD
├── config
├── objects/
└── refs/
```

### 🔍 Inspect `HEAD`

```bash
cat .git/HEAD
```

Usually:

```
ref: refs/heads/main
```

That line tells Git _which branch ref the HEAD points to_.

---

## 🧩 3. Objects — The Heart of Git

Git has 4 core object types:

| Type       | Description                                    |
| ---------- | ---------------------------------------------- |
| **blob**   | file contents                                  |
| **tree**   | directory listing (maps filenames to blob SHA) |
| **commit** | metadata + pointer to tree + parent commits    |
| **tag**    | named reference to a commit (for releases)     |

Each object is stored in `.git/objects/<first2hashchars>/<remaininghash>`
and is compressed + zlib encoded.

---

## 🧠 4. Manually Create Objects

Let’s simulate what Git does automatically.

### 🧾 Create a Blob

```bash
echo "hello world" | git hash-object -w --stdin
```

Output:

```
e9650479fd0a7adf9d6db5f419f34288f0b5d47e
```

This hash _is_ the filename of the blob inside `.git/objects/`.

Verify:

```bash
find .git/objects -type f
```

Inspect it:

```bash
git cat-file -t e96504...   # type: blob
git cat-file -p e96504...   # print contents
```

You just created Git’s smallest possible data unit manually.

---

## 🗂️ 5. Make a Tree Object (directory)

Trees reference blobs (files) and other trees (subdirectories).

First, write a file:

```bash
echo "print('hi')" > app.py
```

Now add it to the _index_ (the staging area):

```bash
git update-index --add app.py
```

The index holds the structure for a future tree.

Create a tree:

```bash
git write-tree
```

Example output:

```
1b2a7d4c54a...  # tree hash
```

Inspect:

```bash
git cat-file -p 1b2a7d4c54a
```

You’ll see something like:

```
100644 blob e9650479fd0a7adf9d6db5f419f34288f0b5d47e	app.py
```

→ A directory entry linking filename → blob hash.

---

## 🧭 6. Create a Commit Manually

Now we attach metadata: author, message, timestamp.

```bash
echo "first commit" | git commit-tree 1b2a7d4c54a
```

Output:

```
9fceb02c0f...   # commit hash
```

Inspect it:

```bash
git cat-file -p 9fceb02c0f
```

```
tree 1b2a7d4c54a...
author Michael <mike@dev> 1728672300 -0400
committer Michael <mike@dev> 1728672300 -0400

first commit
```

That’s literally what a commit _is_: a small plaintext file with metadata and pointers.

Attach HEAD to it:

```bash
git update-ref refs/heads/main 9fceb02c0f
```

Now your repo has its first commit — no `git add`, no `git commit`.

---

## 🧩 7. Understanding References

References are just _named pointers_ to commits.

Check them:

```bash
cat .git/refs/heads/main
```

→ Contains the commit hash you just made.

Move HEAD (detached state):

```bash
git checkout 9fceb02c0f
```

→ HEAD now points directly to a commit hash, not a branch ref.

Create a tag:

```bash
git tag v1.0 9fceb02c0f
cat .git/refs/tags/v1.0
```

---

## 🧮 8. Branching & Merging (Mechanics)

A **branch** is just another pointer.
Creating a branch = making a new ref file.

```bash
git branch feature
```

→ creates `.git/refs/heads/feature` containing the same commit hash.

Now change something, commit again, and notice:

- The branch pointer moves forward.
- The parent commit pointer forms a chain.

```bash
echo "v2" > version.txt
git add version.txt
git commit -m "Add version"
```

Inspect your DAG:

```bash
git log --graph --oneline
```

---

## 🔗 9. Object Relationships

Graphically:

```
Commit A
 │
 └── Tree (root dir)
       ├── Blob (app.py)
       └── Blob (version.txt)
```

Each new commit points back to the previous one:

```
Commit B
 │
 └── parent → Commit A
```

→ That’s the entire Git history structure — a linked list of trees.

---

## 🧰 10. Refspecs, HEAD, and Remotes

- **HEAD** → current checkout target
- **Branch ref** → pointer under `.git/refs/heads/`
- **Remote ref** → `.git/refs/remotes/origin/`
- **Tag ref** → `.git/refs/tags/`

When you `push`:

```bash
git push origin main
```

Git runs a **refspec translation**:
`refs/heads/main` (local) → `refs/heads/main` (remote).

Remotes are just another namespace.

---

## 🧬 11. The Index (Staging Area)

The index (`.git/index`) is a binary file listing file paths, modes, hashes.
It acts as a _transaction buffer_ between working directory and repo.

Check what’s staged:

```bash
git ls-files --stage
```

Rebuild a tree from it:

```bash
git write-tree
```

This separation lets Git commit _atomic snapshots_ efficiently.

---

## 🧠 12. How Git Compresses & Stores Data

Objects live in `.git/objects/` as compressed files.
Run this:

```bash
find .git/objects -type f
```

Git uses:

- **Zlib compression** for each object
- **Delta compression** in packfiles (`.pack` and `.idx`) once the repo is large.

Packfiles reduce redundancy (e.g., multiple similar commits).

Generate one manually:

```bash
git gc
```

→ Rewrites `.git/objects/` into packs.

Inspect:

```bash
ls .git/objects/pack/
```

---

## 🔬 13. The SHA-1 Hash

Every object is identified by `SHA1(<type> + " " + size + \0 + content)`.

You can re-create it manually:

```bash
echo -n "blob 11\0hello world" | openssl sha1
```

Output should match your earlier `git hash-object` result.

This is what makes Git **immutable** — if even 1 byte changes, the hash changes.

---

## 🧩 14. Rebase, Merge, and Fast-Forward (Mechanics)

- **Merge:** Creates a new commit with two parents.
- **Rebase:** Rewrites commit parents (new hashes).
- **Fast-forward:** Just moves a pointer.

Visual:

```
A - B - C (main)
       \
        D - E (feature)
```

→ Merge creates F with parents C and E.
→ Rebase re-attaches D,E after C.

Use:

```bash
git log --graph --oneline --decorate
```

to visualize.

---

## ⚗️ 15. Reset, Checkout, and Reflog

| Command        | What It Does                   | Internally             |
| -------------- | ------------------------------ | ---------------------- |
| `git reset`    | Moves branch pointer           | Updates `refs/heads/*` |
| `git checkout` | Switches HEAD                  | Moves `HEAD` pointer   |
| `git reflog`   | History of where HEAD has been | Stored in `.git/logs/` |

Example:

```bash
git reflog
```

→ You can recover _any lost commit_ because Git logs all pointer moves.

---

## 🧩 16. Detached HEAD Experiment

Try this:

```bash
git checkout HEAD~1
```

Edit a file → commit → notice that no branch pointer moves.
Only HEAD points to that new commit.

→ You’re now in a “floating” state — the commit exists, but no branch references it until you make one:

```bash
git switch -c temp_branch
```

---

## 🧠 17. Garbage Collection and Object Lifetimes

Objects with no reference (branch/tag) eventually get deleted.

- `git reflog expire --expire=now --all`
- `git gc --prune=now`

→ Simulates how Git cleans up unreachable commits.

---

## 🧰 18. Advanced Plumbing Commands Summary

| Command           | Description             |
| ----------------- | ----------------------- |
| `git hash-object` | Create/read raw objects |
| `git cat-file`    | Inspect objects         |
| `git write-tree`  | Create tree objects     |
| `git commit-tree` | Create commit objects   |
| `git update-ref`  | Modify refs manually    |
| `git reflog`      | Show ref history        |
| `git fsck`        | Verify object integrity |
| `git gc`          | Compress repository     |

---

## 🧭 19. Internal References for Further Study

- **Pro Git (Book, Ch.10–11)**: [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)
- **Git from the Inside Out** (Scott Chacon): [https://maryrosecook.com/blog/post/git-from-the-inside-out](https://maryrosecook.com/blog/post/git-from-the-inside-out)
- **Git Object Model Visualization**: [https://learngitbranching.js.org/?locale=en_US](https://learngitbranching.js.org/?locale=en_US)

---

## 🔧 20. Summary

| Concept                                           | Key Insight                  |
| ------------------------------------------------- | ---------------------------- |
| Git is a **hash-based filesystem**                | Not a diff system            |
| Every commit is a **snapshot DAG**                | Efficient history tracking   |
| Plumbing commands reveal **the database layer**   | Not just the porcelain       |
| The **index** is a staging buffer                 | Ensures atomic commits       |
| **Refs and HEAD** form the navigation system      | Branching = pointer movement |
| **Garbage collection** prunes unreachable commits | Keeps repo lean              |

---

### ✅ Lab Review Checklist

- [x] Create blob manually
- [x] Create tree manually
- [x] Create commit manually
- [x] Inspect `.git/refs`, `HEAD`, and index
- [x] Understand SHA1 immutability
- [x] Perform manual fast-forward & rebase visualization

---

Next time we’ll move into **Module 2 – Computer Architecture**,
where you’ll see how the hardware executes your compiled code —
and how versioned source (like you just explored in Git) eventually becomes binary instructions in memory.

---

Would you like me to follow this by creating a **Git plumbing diagram (ASCII + optional SVG)** that maps `HEAD → refs → commits → trees → blobs` visually for inclusion in MkDocs?
