Perfect â€” thatâ€™s the _exact right way_ to learn.
Youâ€™ll master Git as both a _developer tool_ and a _computer science system_, not just as a â€œthing to save your code.â€

Below is **Module 1-Deep Supplement: Git Plumbing & Internals** â€” a self-contained reference you can keep in MkDocs under `docs/foundations/git.md`.
Itâ€™s written like a manual + guided lab: you can read, copy, experiment, and _truly understand how Git works under the hood_.

---

# âš™ï¸ **Git Internals â€” The Plumbing Layer**

> â€œPorcelainâ€ commands are what you use day to day (`git add`, `git commit`).
> â€œPlumbingâ€ commands are what Git itself uses internally â€” the _pipes beneath the sink._

---

## ğŸ§­ 1. Gitâ€™s Mental Model

Git isnâ€™t a diff-based system (like Subversion).
Itâ€™s a **content-addressable filesystem**:
each file, tree, and commit is stored as a **blob object** identified by its **hash** (SHA-1).

```
Working Directory â†’ Staging Area (index) â†’ Repository (.git/objects)
```

Every snapshot points to its parent â€” forming a **directed acyclic graph (DAG)**.

---

## ğŸ§± 2. Build a Git Repo from Raw Plumbing

Letâ€™s create a new repo, but _without_ any porcelain.

```bash
mkdir git_lab && cd git_lab
git init
```

This makes a `.git/` folder â€” the real database.

```
.git/
â”œâ”€â”€ HEAD
â”œâ”€â”€ config
â”œâ”€â”€ objects/
â””â”€â”€ refs/
```

### ğŸ” Inspect `HEAD`

```bash
cat .git/HEAD
```

Usually:

```
ref: refs/heads/main
```

That line tells Git _which branch ref the HEAD points to_.

---

## ğŸ§© 3. Objects â€” The Heart of Git

Git has 4 core object types:

| Type       | Description                                    |
| ---------- | ---------------------------------------------- |
| **blob**   | file contents                                  |
| **tree**   | directory listing (maps filenames to blob SHA) |
| **commit** | metadata + pointer to tree + parent commits    |
| **tag**    | named reference to a commit (for releases)     |

Each object is stored in `.git/objects/<first2hashchars>/<remaininghash>`
and is compressed + zlib encoded.

---

## ğŸ§  4. Manually Create Objects

Letâ€™s simulate what Git does automatically.

### ğŸ§¾ Create a Blob

```bash
echo "hello world" | git hash-object -w --stdin
```

Output:

```
e9650479fd0a7adf9d6db5f419f34288f0b5d47e
```

This hash _is_ the filename of the blob inside `.git/objects/`.

Verify:

```bash
find .git/objects -type f
```

Inspect it:

```bash
git cat-file -t e96504...   # type: blob
git cat-file -p e96504...   # print contents
```

You just created Gitâ€™s smallest possible data unit manually.

---

## ğŸ—‚ï¸ 5. Make a Tree Object (directory)

Trees reference blobs (files) and other trees (subdirectories).

First, write a file:

```bash
echo "print('hi')" > app.py
```

Now add it to the _index_ (the staging area):

```bash
git update-index --add app.py
```

The index holds the structure for a future tree.

Create a tree:

```bash
git write-tree
```

Example output:

```
1b2a7d4c54a...  # tree hash
```

Inspect:

```bash
git cat-file -p 1b2a7d4c54a
```

Youâ€™ll see something like:

```
100644 blob e9650479fd0a7adf9d6db5f419f34288f0b5d47e	app.py
```

â†’ A directory entry linking filename â†’ blob hash.

---

## ğŸ§­ 6. Create a Commit Manually

Now we attach metadata: author, message, timestamp.

```bash
echo "first commit" | git commit-tree 1b2a7d4c54a
```

Output:

```
9fceb02c0f...   # commit hash
```

Inspect it:

```bash
git cat-file -p 9fceb02c0f
```

```
tree 1b2a7d4c54a...
author Michael <mike@dev> 1728672300 -0400
committer Michael <mike@dev> 1728672300 -0400

first commit
```

Thatâ€™s literally what a commit _is_: a small plaintext file with metadata and pointers.

Attach HEAD to it:

```bash
git update-ref refs/heads/main 9fceb02c0f
```

Now your repo has its first commit â€” no `git add`, no `git commit`.

---

## ğŸ§© 7. Understanding References

References are just _named pointers_ to commits.

Check them:

```bash
cat .git/refs/heads/main
```

â†’ Contains the commit hash you just made.

Move HEAD (detached state):

```bash
git checkout 9fceb02c0f
```

â†’ HEAD now points directly to a commit hash, not a branch ref.

Create a tag:

```bash
git tag v1.0 9fceb02c0f
cat .git/refs/tags/v1.0
```

---

## ğŸ§® 8. Branching & Merging (Mechanics)

A **branch** is just another pointer.
Creating a branch = making a new ref file.

```bash
git branch feature
```

â†’ creates `.git/refs/heads/feature` containing the same commit hash.

Now change something, commit again, and notice:

- The branch pointer moves forward.
- The parent commit pointer forms a chain.

```bash
echo "v2" > version.txt
git add version.txt
git commit -m "Add version"
```

Inspect your DAG:

```bash
git log --graph --oneline
```

---

## ğŸ”— 9. Object Relationships

Graphically:

```
Commit A
 â”‚
 â””â”€â”€ Tree (root dir)
       â”œâ”€â”€ Blob (app.py)
       â””â”€â”€ Blob (version.txt)
```

Each new commit points back to the previous one:

```
Commit B
 â”‚
 â””â”€â”€ parent â†’ Commit A
```

â†’ Thatâ€™s the entire Git history structure â€” a linked list of trees.

---

## ğŸ§° 10. Refspecs, HEAD, and Remotes

- **HEAD** â†’ current checkout target
- **Branch ref** â†’ pointer under `.git/refs/heads/`
- **Remote ref** â†’ `.git/refs/remotes/origin/`
- **Tag ref** â†’ `.git/refs/tags/`

When you `push`:

```bash
git push origin main
```

Git runs a **refspec translation**:
`refs/heads/main` (local) â†’ `refs/heads/main` (remote).

Remotes are just another namespace.

---

## ğŸ§¬ 11. The Index (Staging Area)

The index (`.git/index`) is a binary file listing file paths, modes, hashes.
It acts as a _transaction buffer_ between working directory and repo.

Check whatâ€™s staged:

```bash
git ls-files --stage
```

Rebuild a tree from it:

```bash
git write-tree
```

This separation lets Git commit _atomic snapshots_ efficiently.

---

## ğŸ§  12. How Git Compresses & Stores Data

Objects live in `.git/objects/` as compressed files.
Run this:

```bash
find .git/objects -type f
```

Git uses:

- **Zlib compression** for each object
- **Delta compression** in packfiles (`.pack` and `.idx`) once the repo is large.

Packfiles reduce redundancy (e.g., multiple similar commits).

Generate one manually:

```bash
git gc
```

â†’ Rewrites `.git/objects/` into packs.

Inspect:

```bash
ls .git/objects/pack/
```

---

## ğŸ”¬ 13. The SHA-1 Hash

Every object is identified by `SHA1(<type> + " " + size + \0 + content)`.

You can re-create it manually:

```bash
echo -n "blob 11\0hello world" | openssl sha1
```

Output should match your earlier `git hash-object` result.

This is what makes Git **immutable** â€” if even 1 byte changes, the hash changes.

---

## ğŸ§© 14. Rebase, Merge, and Fast-Forward (Mechanics)

- **Merge:** Creates a new commit with two parents.
- **Rebase:** Rewrites commit parents (new hashes).
- **Fast-forward:** Just moves a pointer.

Visual:

```
A - B - C (main)
       \
        D - E (feature)
```

â†’ Merge creates F with parents C and E.
â†’ Rebase re-attaches D,E after C.

Use:

```bash
git log --graph --oneline --decorate
```

to visualize.

---

## âš—ï¸ 15. Reset, Checkout, and Reflog

| Command        | What It Does                   | Internally             |
| -------------- | ------------------------------ | ---------------------- |
| `git reset`    | Moves branch pointer           | Updates `refs/heads/*` |
| `git checkout` | Switches HEAD                  | Moves `HEAD` pointer   |
| `git reflog`   | History of where HEAD has been | Stored in `.git/logs/` |

Example:

```bash
git reflog
```

â†’ You can recover _any lost commit_ because Git logs all pointer moves.

---

## ğŸ§© 16. Detached HEAD Experiment

Try this:

```bash
git checkout HEAD~1
```

Edit a file â†’ commit â†’ notice that no branch pointer moves.
Only HEAD points to that new commit.

â†’ Youâ€™re now in a â€œfloatingâ€ state â€” the commit exists, but no branch references it until you make one:

```bash
git switch -c temp_branch
```

---

## ğŸ§  17. Garbage Collection and Object Lifetimes

Objects with no reference (branch/tag) eventually get deleted.

- `git reflog expire --expire=now --all`
- `git gc --prune=now`

â†’ Simulates how Git cleans up unreachable commits.

---

## ğŸ§° 18. Advanced Plumbing Commands Summary

| Command           | Description             |
| ----------------- | ----------------------- |
| `git hash-object` | Create/read raw objects |
| `git cat-file`    | Inspect objects         |
| `git write-tree`  | Create tree objects     |
| `git commit-tree` | Create commit objects   |
| `git update-ref`  | Modify refs manually    |
| `git reflog`      | Show ref history        |
| `git fsck`        | Verify object integrity |
| `git gc`          | Compress repository     |

---

## ğŸ§­ 19. Internal References for Further Study

- **Pro Git (Book, Ch.10â€“11)**: [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)
- **Git from the Inside Out** (Scott Chacon): [https://maryrosecook.com/blog/post/git-from-the-inside-out](https://maryrosecook.com/blog/post/git-from-the-inside-out)
- **Git Object Model Visualization**: [https://learngitbranching.js.org/?locale=en_US](https://learngitbranching.js.org/?locale=en_US)

---

## ğŸ”§ 20. Summary

| Concept                                           | Key Insight                  |
| ------------------------------------------------- | ---------------------------- |
| Git is a **hash-based filesystem**                | Not a diff system            |
| Every commit is a **snapshot DAG**                | Efficient history tracking   |
| Plumbing commands reveal **the database layer**   | Not just the porcelain       |
| The **index** is a staging buffer                 | Ensures atomic commits       |
| **Refs and HEAD** form the navigation system      | Branching = pointer movement |
| **Garbage collection** prunes unreachable commits | Keeps repo lean              |

---

### âœ… Lab Review Checklist

- [x] Create blob manually
- [x] Create tree manually
- [x] Create commit manually
- [x] Inspect `.git/refs`, `HEAD`, and index
- [x] Understand SHA1 immutability
- [x] Perform manual fast-forward & rebase visualization

---

Next time weâ€™ll move into **Module 2 â€“ Computer Architecture**,
where youâ€™ll see how the hardware executes your compiled code â€”
and how versioned source (like you just explored in Git) eventually becomes binary instructions in memory.

---

Would you like me to follow this by creating a **Git plumbing diagram (ASCII + optional SVG)** that maps `HEAD â†’ refs â†’ commits â†’ trees â†’ blobs` visually for inclusion in MkDocs?
