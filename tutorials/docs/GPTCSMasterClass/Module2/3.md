Perfect choice.
If Module 02 was “Git’s DNA,” then this next section is **how Git _evolves_** — merges, rebases, and conflicts are the _natural laws_ that govern change.
We’ll go line-by-line and inspect Git’s behavior under the hood using **plumbing commands**, so you actually see _what_ changes and _why_.

---

# 🔬 **Module 02.2 — The Mechanics of Change: Merges, Rebases & Conflicts**

> **Goal:** learn exactly what happens to commits, trees, and refs when branches diverge and converge.

---

## ⚙️ 1️⃣ Review: Commits Are Snapshots, Not Diffs

Each commit points to a full tree snapshot of your project, plus its parent commit(s).

```bash
git log --graph --oneline --decorate
```

Example:

```
* a1b2c3d (HEAD -> main) Added logging
* 9f8e7d6 Added parser
* 1a2b3c4 Initial commit
```

When you edit a file and commit, Git creates **a new blob**, **a new tree**, and **a new commit** that points to the previous one — forming a **chain**.

---

## ⚙️ 2️⃣ Branching Is Pointer Management

Branches are just _labels_ for commit hashes.

Let’s make two:

```bash
echo "main" > readme.txt
git add .
git commit -m "main commit"

git branch feature
git checkout feature
```

Now you have:

```
* (HEAD -> feature, main)
```

> Both `main` and `feature` point to the same commit.
> Moving one pointer doesn’t change the other.

---

## ⚙️ 3️⃣ Divergence — Two Lines of History

Make two unique commits on each branch.

```bash
# On feature
echo "feature work" >> readme.txt
git commit -am "feature commit"

# Switch back
git checkout main
echo "mainline work" >> readme.txt
git commit -am "main commit"
```

Now visualize:

```bash
git log --graph --decorate --oneline --all
```

Output:

```
* bbbb111 (feature) feature commit
| * aaaa222 (HEAD -> main) main commit
|/
* 9999999 Initial commit
```

Two **branches diverged** — two histories from a common ancestor.

---

## ⚙️ 4️⃣ Merge (Two Parents, One Child)

A merge commit has **two parents**: one from each branch.

```bash
git checkout main
git merge feature -m "merge feature into main"
```

Inspect the new commit:

```bash
git cat-file -p HEAD
```

You’ll see:

```
tree <hash>
parent aaaa222
parent bbbb111
author ...
committer ...
merge feature into main
```

Now `HEAD` (main) points to a commit with _two parents_.
That’s the “Y” shape of history.

Visualize again:

```bash
git log --graph --oneline --all
```

---

### 🧩 What Git Actually Did During Merge

1. Found the **common ancestor** (the “merge base”)
2. Compared:

   - Base → main
   - Base → feature

3. Applied changes from both into a new snapshot (tree)
4. Created a commit pointing to both parents

If there were no conflicts → automatic merge.

---

## ⚙️ 5️⃣ Conflict Simulation

Let’s make Git sweat.

```bash
git checkout feature
echo "Feature edit" > conflict.txt
git add .
git commit -m "feature edit"

git checkout main
echo "Main edit" > conflict.txt
git add .
git commit -m "main edit"

git merge feature
```

Now Git can’t auto-merge.
You’ll see something like:

```
Auto-merging conflict.txt
CONFLICT (content): Merge conflict in conflict.txt
```

---

### 🔍 What Happened?

Open the file:

```bash
cat conflict.txt
```

You’ll see:

```
<<<<<<< HEAD
Main edit
=======
Feature edit
>>>>>>> feature
```

That’s the _three-way merge marker_:

- **HEAD** = your branch
- **feature** = theirs
- The base (common ancestor) is implied

---

### 🧠 Conflict Resolution Flow

```bash
# 1. Edit the file manually
nano conflict.txt
# (keep correct version, delete markers)

# 2. Stage resolved file
git add conflict.txt

# 3. Complete the merge
git commit
```

Git now creates a normal merge commit — same as before, just with your chosen resolution.

---

## ⚙️ 6️⃣ The Rebase – Rewriting History

Where merge **combines**, rebase **replays**.

```bash
git checkout feature
git rebase main
```

Git finds the base (divergence point), temporarily _removes_ your commits, updates your branch to the tip of `main`, then _replays_ your commits one by one.

Visual difference:

| Merge                                     | Rebase                                                  |
| ----------------------------------------- | ------------------------------------------------------- |
| Creates a new merge commit with 2 parents | Rewrites commit history as if your branch started later |
| Preserves full DAG shape                  | Linearizes history                                      |
| Good for collaborative history            | Good for private cleanup                                |

---

### 🔬 What Git Does Internally During Rebase

1. `git rev-list` to find commits unique to your branch
2. Applies each diff (patch) sequentially to the new base tree
3. For each, creates a **new commit** (new hashes!)
4. Updates your branch ref to the last new commit

So rebased commits are _new objects_ — the originals remain until garbage collection.

Inspect with:

```bash
git reflog
```

You’ll see the old ones still listed.

---

## ⚙️ 7️⃣ Interactive Rebase — Surgical History Editing

You can reorder, squash, or edit commits:

```bash
git rebase -i HEAD~3
```

Editor opens:

```
pick a1b2c3 First change
pick d4e5f6 Second change
pick g7h8i9 Third change
```

Change to:

```
pick a1b2c3 First change
squash d4e5f6 Second change
reword g7h8i9 Cleanup message
```

You’ve just _surgically rewritten history_.

> Use interactives before pushing to shared branches — never rewrite public history.

---

## ⚙️ 8️⃣ Cherry-Picking

To apply one commit elsewhere:

```bash
git checkout main
git cherry-pick bbbb111
```

Git:

- Retrieves the commit’s diff
- Applies it to your current tree
- Makes a new commit on top

Like rebase, the new commit has a new hash (new object).

---

## ⚙️ 9️⃣ Detached HEAD State

You can “time travel” to any commit hash:

```bash
git checkout <hash>
```

Now HEAD points directly to a commit, not a branch ref.

If you commit here:

```bash
echo "temp" > temp.txt
git commit -am "temp change"
```

You’ll see:

```
HEAD detached at <hash>
```

Once you move away, that commit may become unreachable — unless you make a branch:

```bash
git switch -c saved-work
```

---

## ⚙️ 🔧 10️⃣ Reset vs Revert — Undoing Work

| Command                    | Effect                                                                     |
| -------------------------- | -------------------------------------------------------------------------- |
| `git reset --soft <hash>`  | Moves HEAD; keeps staged and working changes                               |
| `git reset --mixed <hash>` | Moves HEAD; keeps working changes, unstaged                                |
| `git reset --hard <hash>`  | Moves HEAD and wipes all changes                                           |
| `git revert <hash>`        | Creates a new commit that undoes a previous one (safe for shared branches) |

### Demo:

```bash
git reset --hard HEAD~1
```

HEAD now points to one commit earlier.

To _undo_ that reset:

```bash
git reflog
git checkout -b recovery HEAD@{1}
```

---

## ⚙️ 11️⃣ Merge vs Rebase Recap

| Concept               | Merge                    | Rebase                    |
| --------------------- | ------------------------ | ------------------------- |
| Structure             | 2 parents                | Linear                    |
| Commit Hashes         | Preserved                | New ones created          |
| Safe on shared branch | ✅                       | ❌ (changes history)      |
| Keeps full history    | ✅                       | No (rewrites)             |
| Use when              | Integrating others’ work | Cleaning up your own work |

---

## ⚙️ 12️⃣ Manual Merge Object Creation (Advanced Plumbing)

You can create a merge commit manually using low-level commands:

```bash
# Suppose you have two commits
git cat-file -p main^{tree} > /tmp/treeA
git cat-file -p feature^{tree} > /tmp/treeB

# Merge base tree
git merge-base main feature
# use git read-tree, write-tree, commit-tree
```

Not practical for daily use, but this shows Git’s _merge_ is just tree manipulation.

---

## 🧩 Checkpoint Exercise

✅ Create a repo
✅ Make two branches, commit to each
✅ Perform:

- A merge (no conflict)
- A merge (with conflict)
- A rebase
- A cherry-pick
- A hard reset & recovery via reflog
  ✅ Explain each action’s effect on:

  - `.git/HEAD`
  - `.git/refs`
  - `.git/objects`

If you can answer those → you _know Git_ more deeply than most working developers.

---

## 📚 Suggested Resources

- [Pro Git, Chapter 10 – Plumbing and Porcelain](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)
- [Think Like (a) Git](https://think-like-a-git.net/)
- `git help glossary` (built-in terminology reference)
- Git Internals Videos – _ThePrimeagen_ (YouTube)

---

If you’re ready, the **next deep section** can show:

> 🔬 How Git manages **remotes, fetch, pull, and push** — the exact object transfers and reference updates between your local `.git` and a remote repo (GitHub or bare repo).

Would you like to continue directly into **Git Remotes and Network Internals (Module 02.3)** next?
