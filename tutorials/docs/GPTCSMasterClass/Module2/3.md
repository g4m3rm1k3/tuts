Perfect choice.
If Module 02 was â€œGitâ€™s DNA,â€ then this next section is **how Git _evolves_** â€” merges, rebases, and conflicts are the _natural laws_ that govern change.
Weâ€™ll go line-by-line and inspect Gitâ€™s behavior under the hood using **plumbing commands**, so you actually see _what_ changes and _why_.

---

# ğŸ”¬ **Module 02.2 â€” The Mechanics of Change: Merges, Rebases & Conflicts**

> **Goal:** learn exactly what happens to commits, trees, and refs when branches diverge and converge.

---

## âš™ï¸ 1ï¸âƒ£ Review: Commits Are Snapshots, Not Diffs

Each commit points to a full tree snapshot of your project, plus its parent commit(s).

```bash
git log --graph --oneline --decorate
```

Example:

```
* a1b2c3d (HEAD -> main) Added logging
* 9f8e7d6 Added parser
* 1a2b3c4 Initial commit
```

When you edit a file and commit, Git creates **a new blob**, **a new tree**, and **a new commit** that points to the previous one â€” forming a **chain**.

---

## âš™ï¸ 2ï¸âƒ£ Branching Is Pointer Management

Branches are just _labels_ for commit hashes.

Letâ€™s make two:

```bash
echo "main" > readme.txt
git add .
git commit -m "main commit"

git branch feature
git checkout feature
```

Now you have:

```
* (HEAD -> feature, main)
```

> Both `main` and `feature` point to the same commit.
> Moving one pointer doesnâ€™t change the other.

---

## âš™ï¸ 3ï¸âƒ£ Divergence â€” Two Lines of History

Make two unique commits on each branch.

```bash
# On feature
echo "feature work" >> readme.txt
git commit -am "feature commit"

# Switch back
git checkout main
echo "mainline work" >> readme.txt
git commit -am "main commit"
```

Now visualize:

```bash
git log --graph --decorate --oneline --all
```

Output:

```
* bbbb111 (feature) feature commit
| * aaaa222 (HEAD -> main) main commit
|/
* 9999999 Initial commit
```

Two **branches diverged** â€” two histories from a common ancestor.

---

## âš™ï¸ 4ï¸âƒ£ Merge (Two Parents, One Child)

A merge commit has **two parents**: one from each branch.

```bash
git checkout main
git merge feature -m "merge feature into main"
```

Inspect the new commit:

```bash
git cat-file -p HEAD
```

Youâ€™ll see:

```
tree <hash>
parent aaaa222
parent bbbb111
author ...
committer ...
merge feature into main
```

Now `HEAD` (main) points to a commit with _two parents_.
Thatâ€™s the â€œYâ€ shape of history.

Visualize again:

```bash
git log --graph --oneline --all
```

---

### ğŸ§© What Git Actually Did During Merge

1. Found the **common ancestor** (the â€œmerge baseâ€)
2. Compared:

   - Base â†’ main
   - Base â†’ feature

3. Applied changes from both into a new snapshot (tree)
4. Created a commit pointing to both parents

If there were no conflicts â†’ automatic merge.

---

## âš™ï¸ 5ï¸âƒ£ Conflict Simulation

Letâ€™s make Git sweat.

```bash
git checkout feature
echo "Feature edit" > conflict.txt
git add .
git commit -m "feature edit"

git checkout main
echo "Main edit" > conflict.txt
git add .
git commit -m "main edit"

git merge feature
```

Now Git canâ€™t auto-merge.
Youâ€™ll see something like:

```
Auto-merging conflict.txt
CONFLICT (content): Merge conflict in conflict.txt
```

---

### ğŸ” What Happened?

Open the file:

```bash
cat conflict.txt
```

Youâ€™ll see:

```
<<<<<<< HEAD
Main edit
=======
Feature edit
>>>>>>> feature
```

Thatâ€™s the _three-way merge marker_:

- **HEAD** = your branch
- **feature** = theirs
- The base (common ancestor) is implied

---

### ğŸ§  Conflict Resolution Flow

```bash
# 1. Edit the file manually
nano conflict.txt
# (keep correct version, delete markers)

# 2. Stage resolved file
git add conflict.txt

# 3. Complete the merge
git commit
```

Git now creates a normal merge commit â€” same as before, just with your chosen resolution.

---

## âš™ï¸ 6ï¸âƒ£ The Rebase â€“ Rewriting History

Where merge **combines**, rebase **replays**.

```bash
git checkout feature
git rebase main
```

Git finds the base (divergence point), temporarily _removes_ your commits, updates your branch to the tip of `main`, then _replays_ your commits one by one.

Visual difference:

| Merge                                     | Rebase                                                  |
| ----------------------------------------- | ------------------------------------------------------- |
| Creates a new merge commit with 2 parents | Rewrites commit history as if your branch started later |
| Preserves full DAG shape                  | Linearizes history                                      |
| Good for collaborative history            | Good for private cleanup                                |

---

### ğŸ”¬ What Git Does Internally During Rebase

1. `git rev-list` to find commits unique to your branch
2. Applies each diff (patch) sequentially to the new base tree
3. For each, creates a **new commit** (new hashes!)
4. Updates your branch ref to the last new commit

So rebased commits are _new objects_ â€” the originals remain until garbage collection.

Inspect with:

```bash
git reflog
```

Youâ€™ll see the old ones still listed.

---

## âš™ï¸ 7ï¸âƒ£ Interactive Rebase â€” Surgical History Editing

You can reorder, squash, or edit commits:

```bash
git rebase -i HEAD~3
```

Editor opens:

```
pick a1b2c3 First change
pick d4e5f6 Second change
pick g7h8i9 Third change
```

Change to:

```
pick a1b2c3 First change
squash d4e5f6 Second change
reword g7h8i9 Cleanup message
```

Youâ€™ve just _surgically rewritten history_.

> Use interactives before pushing to shared branches â€” never rewrite public history.

---

## âš™ï¸ 8ï¸âƒ£ Cherry-Picking

To apply one commit elsewhere:

```bash
git checkout main
git cherry-pick bbbb111
```

Git:

- Retrieves the commitâ€™s diff
- Applies it to your current tree
- Makes a new commit on top

Like rebase, the new commit has a new hash (new object).

---

## âš™ï¸ 9ï¸âƒ£ Detached HEAD State

You can â€œtime travelâ€ to any commit hash:

```bash
git checkout <hash>
```

Now HEAD points directly to a commit, not a branch ref.

If you commit here:

```bash
echo "temp" > temp.txt
git commit -am "temp change"
```

Youâ€™ll see:

```
HEAD detached at <hash>
```

Once you move away, that commit may become unreachable â€” unless you make a branch:

```bash
git switch -c saved-work
```

---

## âš™ï¸ ğŸ”§ 10ï¸âƒ£ Reset vs Revert â€” Undoing Work

| Command                    | Effect                                                                     |
| -------------------------- | -------------------------------------------------------------------------- |
| `git reset --soft <hash>`  | Moves HEAD; keeps staged and working changes                               |
| `git reset --mixed <hash>` | Moves HEAD; keeps working changes, unstaged                                |
| `git reset --hard <hash>`  | Moves HEAD and wipes all changes                                           |
| `git revert <hash>`        | Creates a new commit that undoes a previous one (safe for shared branches) |

### Demo:

```bash
git reset --hard HEAD~1
```

HEAD now points to one commit earlier.

To _undo_ that reset:

```bash
git reflog
git checkout -b recovery HEAD@{1}
```

---

## âš™ï¸ 11ï¸âƒ£ Merge vs Rebase Recap

| Concept               | Merge                    | Rebase                    |
| --------------------- | ------------------------ | ------------------------- |
| Structure             | 2 parents                | Linear                    |
| Commit Hashes         | Preserved                | New ones created          |
| Safe on shared branch | âœ…                       | âŒ (changes history)      |
| Keeps full history    | âœ…                       | No (rewrites)             |
| Use when              | Integrating othersâ€™ work | Cleaning up your own work |

---

## âš™ï¸ 12ï¸âƒ£ Manual Merge Object Creation (Advanced Plumbing)

You can create a merge commit manually using low-level commands:

```bash
# Suppose you have two commits
git cat-file -p main^{tree} > /tmp/treeA
git cat-file -p feature^{tree} > /tmp/treeB

# Merge base tree
git merge-base main feature
# use git read-tree, write-tree, commit-tree
```

Not practical for daily use, but this shows Gitâ€™s _merge_ is just tree manipulation.

---

## ğŸ§© Checkpoint Exercise

âœ… Create a repo
âœ… Make two branches, commit to each
âœ… Perform:

- A merge (no conflict)
- A merge (with conflict)
- A rebase
- A cherry-pick
- A hard reset & recovery via reflog
  âœ… Explain each actionâ€™s effect on:

  - `.git/HEAD`
  - `.git/refs`
  - `.git/objects`

If you can answer those â†’ you _know Git_ more deeply than most working developers.

---

## ğŸ“š Suggested Resources

- [Pro Git, Chapter 10 â€“ Plumbing and Porcelain](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)
- [Think Like (a) Git](https://think-like-a-git.net/)
- `git help glossary` (built-in terminology reference)
- Git Internals Videos â€“ _ThePrimeagen_ (YouTube)

---

If youâ€™re ready, the **next deep section** can show:

> ğŸ”¬ How Git manages **remotes, fetch, pull, and push** â€” the exact object transfers and reference updates between your local `.git` and a remote repo (GitHub or bare repo).

Would you like to continue directly into **Git Remotes and Network Internals (Module 02.3)** next?
