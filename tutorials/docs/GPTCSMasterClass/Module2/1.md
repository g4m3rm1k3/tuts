Perfect — you’ve got the mindset of a true systems craftsman.
We’ll stay in **logical order**, moving module-by-module, always deep enough to _understand and apply_, not just follow.

Since we’ve fully unpacked **Module 01: Environment & Tools**,
we now move to **Module 02: Git – Fundamentals & Flow** — the _heart_ of how every serious developer or engineer manages and communicates code.

---

# 🧭 **Module 02: Git Fundamentals & Flow**

> **Goal:** Understand Git _conceptually and practically_ — not just the commands, but what’s really happening under the hood (the _plumbing_). You’ll know how to use Git like a craftsman, not a button-clicker.

---

## ⚙️ Step 1: Why Git Exists

### 🧩 Problem It Solves

Before Git, developers used systems like **CVS** and **Subversion (SVN)** — centralized systems where one server held the “truth” of the codebase.
If that server went down, collaboration stopped. Merging changes was slow, often manual, and prone to break everything.

### 💡 Git’s Core Philosophy

Git (created by Linus Torvalds in 2005 for the Linux kernel) introduced a **distributed model**:

- Every clone of a repository is a _full copy_ of the entire history.
- Merges are fast and mostly automatic.
- Branching is cheap, so experimentation is encouraged.

Git isn’t a cloud service — it’s a **tool** that tracks content and changes using **snapshots**, not diffs (this is a key insight).

> **Analogy:** Think of Git as a **time machine** for your project, where every commit is a complete snapshot of your work.

---

## ⚙️ Step 2: Git’s Architecture (Mental Model)

### 🧠 The Four Areas

1. **Working Directory** — your actual files on disk.
2. **Staging Area (Index)** — the “prep zone” for what you _intend_ to include in your next commit.
3. **Local Repository (`.git/`)** — contains all commits, branches, tags, and metadata.
4. **Remote Repository** — e.g., GitHub, GitLab, Bitbucket.

```
[ Working Directory ] → git add → [ Staging Area ] → git commit → [ Local Repo ] → git push → [ Remote Repo ]
```

Each arrow represents a deliberate decision. Git never assumes; you tell it what to track.

---

## ⚙️ Step 3: Git Objects (The Plumbing)

Git stores everything as four fundamental objects:

| Object Type | Description                                           | Example                         |
| ----------- | ----------------------------------------------------- | ------------------------------- |
| **Blob**    | A snapshot of a file’s contents                       | `hello.c` at one moment in time |
| **Tree**    | Directory listing (maps names → blobs/trees)          | Represents folder structure     |
| **Commit**  | Snapshot pointer + metadata (author, message, parent) | “Version checkpoint”            |
| **Tag**     | A named reference to a specific commit                | “v1.0.0” release                |

Each object is identified by a **SHA-1 hash** (40-character hexadecimal ID).

You can inspect them directly:

```bash
git cat-file -p <hash>
```

> 📘 Example: Git doesn’t store diffs; each commit references **trees** and **blobs** that point to file snapshots. Unchanged blobs are reused via hashes — that’s why Git is efficient.

---

## ⚙️ Step 4: Git Plumbing Commands

Let’s get hands-on and see the “raw guts” of Git.
You’ll learn how the porcelain commands (`git add`, `git commit`) are built on these.

1. **Create a repo manually**

   ```bash
   mkdir git-demo && cd git-demo
   git init
   ```

   Creates `.git/` — inspect it:

   ```bash
   tree .git
   ```

2. **Add a file**

   ```bash
   echo "Hello Git" > hello.txt
   git hash-object -w hello.txt
   ```

   `-w` writes the blob to `.git/objects`.
   You can view it with:

   ```bash
   git cat-file -p <blob_hash>
   ```

3. **Create a tree**

   ```bash
   git update-index --add --cacheinfo 100644 <blob_hash> hello.txt
   tree_hash=$(git write-tree)
   echo $tree_hash
   git cat-file -p $tree_hash
   ```

4. **Commit manually**

   ```bash
   echo "Initial commit" | git commit-tree $tree_hash
   ```

   That outputs a **commit hash** — the raw creation of history.

> 🧩 This is literally what `git add` and `git commit` automate. Understanding it means you _own_ Git, not just use it.

---

## ⚙️ Step 5: Branching and HEAD

Git branches are just **pointers** to commits.

- `master` or `main` is the default branch pointer.
- `HEAD` points to your current branch (or directly to a commit if in “detached HEAD” state).

```bash
git branch feature-x
git checkout feature-x
```

Now `HEAD → refs/heads/feature-x`.

You can visualize:

```bash
git log --oneline --graph --all
```

---

## ⚙️ Step 6: Undoing & Exploring

Git lets you move safely through time:

| Command                     | Meaning                           |
| --------------------------- | --------------------------------- |
| `git restore <file>`        | Undo changes in working dir       |
| `git reset --soft <commit>` | Move HEAD but keep staged changes |
| `git reset --hard <commit>` | Reset everything to that commit   |
| `git reflog`                | See every HEAD move ever          |
| `git show <commit>`         | Show commit details               |

> ⚠️ Rule of thumb: `restore` is safe (working dir), `reset` rewrites history (local), `reflog` rescues you when lost.

---

## ⚙️ Step 7: Visualizing Git Internals

Run:

```bash
git log --graph --decorate --oneline --all
```

Or use an online playground like [**learngitbranching.js.org**](https://learngitbranching.js.org/)
→ Interactive visualizer for how commits and branches evolve.

---

## ⚙️ Step 8: Summary – Git’s Core Principles

| Concept                         | Meaning                                         |
| ------------------------------- | ----------------------------------------------- |
| Git tracks _content_, not files | Each blob is stored once, even if renamed       |
| Branches are just refs          | Super-lightweight pointers                      |
| Merges combine histories        | Git uses 3-way merge algorithm                  |
| Commits are immutable           | History is a DAG (directed acyclic graph)       |
| Distributed model               | Every clone = full repo (no central dependency) |

---

## 📘 Resources

- 📖 **Pro Git** by Scott Chacon & Ben Straub – [free online](https://git-scm.com/book/en/v2)
- 🧩 [Learn Git Branching](https://learngitbranching.js.org/)
- 📺 [The Git Parable](https://tom.preston-werner.com/2009/05/19/the-git-parable.html)
- ⚙️ [Git Internals – Peeking under the hood](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)

---

## ✅ Next (Module 03 Preview)

Once you’ve practiced the plumbing and porcelain manually,
we’ll move to **Module 03: Version Control in Real Projects** —
GitHub remotes, `.gitignore`, SSH keys, and collaboration flow.

---

Would you like me to:

- A️⃣ expand this module _even deeper_ into **Git plumbing and object inspection**, showing **manual creation of branches and refs** from the filesystem level (`.git/refs/`), or
- B️⃣ move on to **Module 03: Git Remotes & Collaboration**, now that you’ve got a solid internal model?
