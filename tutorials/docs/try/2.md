# Module 1 Part 2: Configuration - Making Your App Adaptable

## Part 1: Understanding the Problem (No Code Yet)

**Engineering Question:** Why do we need configuration at all? Why not just hardcode everything?

Let's think through a scenario:

**Scenario 1: Development**

- GitLab URL: `http://localhost:3000` (your local GitLab instance)
- Port: `8000`
- Debug mode: `ON`
- SSL verification: `OFF` (self-signed cert)

**Scenario 2: Production**

- GitLab URL: `https://gitlab.company.com`
- Port: `80` or `443`
- Debug mode: `OFF`
- SSL verification: `ON`

**If you hardcode port 8000**, how do you deploy to production? Edit the code and redeploy? That's error-prone and violates a key principle:

**"The same code should run in all environments."**

Configuration is how we achieve this.

---

## Part 2: The Evolution of Configuration

Let's build this in stages so you see WHY each solution exists.

### Stage 1: Hardcoded (The Problem)

Right now, your `main.py` has:

```python
uvicorn.run(app, host="127.0.0.1", port=8000)
```

**The problem:** To change the port, you must edit code. In a team of 5 people, everyone might want different ports for development.

---

### Stage 2: Environment Variables (First Solution)

**The idea:** Read configuration from the environment, not the code.

**Type this into your terminal:**

```bash
export PORT=9000
```

Now Python can read it:

```python
import os
port = int(os.environ.get("PORT", 8000))
```

**Better!** Now each developer sets their own `PORT` without editing code.

**But there's still a problem:**

- What if someone forgets to set `PORT`?
- What if they set `PORT=hello`?
- How do you track which variables are required?

---

### Stage 3: Pydantic Settings (The Right Solution)

**Pydantic Settings gives us:**

1. **Type safety** - `PORT=hello` fails at startup, not at runtime
2. **Defaults** - If not set, use a sane default
3. **Validation** - Port must be 1-65535
4. **Documentation** - All settings in one place
5. **Loading from files** - Can read from `.env` files

This is what we're going to build.

---

## Part 3: Building the Config System

### Step 1: Add Dependencies

**Open `backend/requirements.txt` and ADD these lines:**

```txt
fastapi==0.115.0
uvicorn[standard]==0.31.0
pydantic==2.9.2
pydantic-settings==2.5.2
```

**Stop. What did you add?**

**`pydantic==2.9.2`** - The validation library

- Defines data models with types
- Validates data automatically
- Your `schemas.py` already uses this!

**`pydantic-settings==2.5.2`** - Extension for configuration

- Loads settings from environment variables
- Loads from `.env` files
- Validates configuration at startup

**Install them:**

```bash
pip install -r requirements.txt
```

---

### Step 2: Create the Config Module

**Create the folder:**

```bash
mkdir backend/app/core
```

**Create `backend/app/core/__init__.py`:**

```python
# Empty file - marks 'core' as a Python package
```

**Why an empty `__init__.py`?**

It tells Python: "This folder contains importable modules."

Without it, `from app.core.config import settings` won't work.

---

### Step 3: Build the Settings Class (Piece by Piece)

**Create `backend/app/core/config.py`**

#### Piece 1: The Imports

**Type this:**

```python
from pydantic_settings import BaseSettings
```

**Stop. What is `BaseSettings`?**

It's a base class that gives us superpowers:

- Automatically reads environment variables
- Validates types
- Provides defaults
- Can load from `.env` files

**We're going to inherit from it.**

---

#### Piece 2: Define the Settings Class

**Add this:**

```python
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    # Server settings
    host: str = "127.0.0.1"
    port: int = 8000
```

**Stop. Let's understand this syntax:**

**`host: str = "127.0.0.1"`** means:

1. There's a setting called `host`
2. It must be a string (`: str`)
3. If not provided, use `"127.0.0.1"` as default (`= "..."`)

**How does it read from environment?**

When you create a `Settings()` instance, Pydantic:

1. Looks for environment variable `HOST`
2. If found, uses that value
3. If not found, uses the default `"127.0.0.1"`
4. Validates it's a string
5. If validation fails, crashes with a clear error

**Example:**

```bash
export HOST=0.0.0.0
export PORT=9000
python main.py
# Settings will use host="0.0.0.0", port=9000
```

---

#### Piece 3: Add More Settings

**Add these settings:**

```python
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    # Server settings
    host: str = "127.0.0.1"
    port: int = 8000
    debug: bool = True

    # Application metadata
    app_name: str = "Mastercam PDM"
    app_version: str = "2.0"
```

**Stop. Notice the `debug: bool = True` line:**

**What happens if someone does:**

```bash
export DEBUG=yes
```

Pydantic is smart! It converts common boolean representations:

- `"true"`, `"True"`, `"1"`, `"yes"` → `True`
- `"false"`, `"False"`, `"0"`, `"no"` → `False`

**But if someone does `export DEBUG=maybe`**, Pydantic raises a validation error at startup.

**This is fail-fast design** - invalid config crashes immediately with a clear message, not mysteriously at runtime.

---

#### Piece 4: Configure How Settings Load

**Add this at the end of the class:**

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    # Server settings
    host: str = "127.0.0.1"
    port: int = 8000
    debug: bool = True

    # Application metadata
    app_name: str = "Mastercam PDM"
    app_version: str = "2.0"

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )
```

**Stop. What does `model_config` do?**

It's configuration FOR the configuration system (meta-configuration):

**`env_file=".env"`** - Also look in a `.env` file for settings

- Developers can create `backend/.env` with their personal settings
- Don't commit `.env` to Git (add to `.gitignore`)

**`env_file_encoding="utf-8"`** - Handle international characters properly

**`case_sensitive=False`** - `HOST`, `host`, and `Host` all work

- Linux is case-sensitive, Windows isn't
- This makes your app work consistently everywhere

---

#### Piece 5: Create a Singleton Instance

**Add this at the BOTTOM of the file (outside the class):**

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    # Server settings
    host: str = "127.0.0.1"
    port: int = 8000
    debug: bool = True

    # Application metadata
    app_name: str = "Mastercam PDM"
    app_version: str = "2.0"

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )


# Create a single instance
settings = Settings()
```

**Stop. Why create `settings` here?**

**This is the Singleton pattern.**

**The problem it solves:**

- Configuration is global state
- You want ONE source of truth
- Everyone should see the same settings

**What happens when this module is imported:**

1. Python runs the file top to bottom
2. Defines the `Settings` class
3. Creates `settings = Settings()` - ONE instance
4. That instance lives in memory for the entire program lifetime

**When other files do `from app.core.config import settings`, they all get the SAME object.**

---

### Your Complete `config.py` (For Now)

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    # Server settings
    host: str = "127.0.0.1"
    port: int = 8000
    debug: bool = True

    # Application metadata
    app_name: str = "Mastercam PDM"
    app_version: str = "2.0"

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )


# Create a single instance
settings = Settings()
```

---

## Part 4: Use the Config in Your App

### Update `main.py`

**Open `backend/app/main.py` and modify it:**

**Change this section:**

```python
from fastapi import FastAPI

app = FastAPI(
    title="Mastercam PDM",
    version="2.0"
)
```

**To this:**

```python
from fastapi import FastAPI
from app.core.config import settings

app = FastAPI(
    title=settings.app_name,
    version=settings.app_version
)
```

**Stop. What changed?**

**Before:** Hardcoded strings
**After:** Reading from config

**Why does this matter?**

Now if you want to change the app name, you don't edit code. You set an environment variable:

```bash
export APP_NAME="My Custom PDM"
```

---

**Also update the test block at the bottom:**

**Change this:**

```python
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
```

**To this:**

```python
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host=settings.host, port=settings.port)
```

**Now the port comes from config!**

---

### Your Complete Updated `main.py`

```python
from fastapi import FastAPI
from app.core.config import settings

app = FastAPI(
    title=settings.app_name,
    version=settings.app_version
)

@app.get("/health")
def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host=settings.host, port=settings.port)
```

---

## Part 5: Test the Configuration System

### Test 1: Default Configuration

**Run the app:**

```bash
python app/main.py
```

**Should see:**

```
INFO:     Uvicorn running on http://127.0.0.1:8000
```

It's using the defaults from your `Settings` class.

---

### Test 2: Override with Environment Variables

**Stop the server (Ctrl+C), then:**

```bash
export PORT=9000
export APP_NAME="My PDM System"
python app/main.py
```

**Should see:**

```
INFO:     Uvicorn running on http://127.0.0.1:9000
```

**Visit:** `http://127.0.0.1:9000/docs`

**Look at the page title** - it should say "My PDM System" instead of "Mastercam PDM"!

---

### Test 3: Using a .env File

**Create `backend/.env`:**

```
PORT=7000
APP_NAME=Development PDM
DEBUG=true
```

**Run the app:**

```bash
python app/main.py
```

**It should start on port 7000!**

**The load order is:**

1. Defaults in the Settings class
2. Values from `.env` file (if it exists)
3. Environment variables (highest priority)

---

## Part 6: Understanding What We Built

**Question:** Why is this better than just using `os.environ.get()`?

**Answer - Type Safety:**

```python
# Old way - DANGEROUS
port = os.environ.get("PORT", 8000)  # Returns a STRING!
uvicorn.run(app, port=port)  # CRASH at runtime!

# Pydantic way - SAFE
port = settings.port  # Guaranteed to be an int
uvicorn.run(app, port=port)  # Works!
```

**Answer - Validation:**

```python
# If someone does: export PORT=99999
# Pydantic can validate it's in range 1-65535
# Crashes at startup with clear error, not mysteriously later
```

**Answer - Documentation:**

```python
# All your configuration in ONE place
# New developer? Read Settings class to see all options
# No hunting through code for hardcoded values
```

---

## Part 7: The Next Level (Your ConfigManager)

**What you've built so far is the foundation.** But your actual app needs more:

**You need:**

- GitLab URL, project ID, token
- Encryption for the token (don't store it in plain text!)
- A JSON file to persist config (not just environment variables)
- Loading and saving logic

**I saw your `config.py` file - it has a great `ConfigManager` class with:**

- Encryption via Fernet
- JSON file persistence
- Smart defaults

**In the next section, I'm going to teach you how to build that ConfigManager step by step.**

But first, let me make sure you understand what we've built so far.

---

## What You Have Now

```
backend/
├── app/
│   ├── core/
│   │   ├── __init__.py
│   │   └── config.py     (Your basic settings)
│   └── main.py           (Using settings)
├── .env                  (Your personal config)
└── requirements.txt      (4 dependencies now)
```

---

## Before We Continue

**Verify:**

1. Can you change the port via `.env` file?
2. Can you override it with `export PORT=9999`?
3. Do you understand the load priority (defaults → .env → environment)?
4. Do you understand WHY this is better than hardcoding?

**Answer these questions:**

- What happens if you do `export PORT=hello`?
- Why is `settings` created outside the class?
- What does `case_sensitive=False` do?

---

**When you're ready, tell me: "Ready for ConfigManager"**

**Then I'll teach you how to build:**

- File-based configuration (JSON)
- Encryption for sensitive data
- Load/save logic
- The full ConfigManager pattern from your existing code

Sound good?
