# Module 1: The Foundation - Building the Server Core (The Right Way)

## Part 1: Understanding What We're Building (No Code Yet)

Before we write a single line, let's think through the architecture.

**The Big Picture Question:** What does a web server actually DO?

Answer: It sits there, listens for requests, and responds. That's it. Everything else is details.

```
Browser ──────> [Your Server] ──────> Response
         HTTP Request         JSON/HTML
```

**Our job in Module 1:** Get this basic loop working. One request in, one response out.

---

## Part 2: The Engineering Decisions

### Decision 1: Why FastAPI?

You could build this with Flask, Django, or plain Python sockets. Why FastAPI?

**FastAPI gives us 4 things for free:**

1. **Automatic validation** - If an endpoint expects a username, FastAPI rejects garbage automatically
2. **Auto-generated docs** - `/docs` endpoint appears magically
3. **Type safety** - Catch bugs before runtime with type hints
4. **Async support** - When we call Git commands (I/O), the server can handle other requests

**The principle:** Choose tools that eliminate entire classes of bugs and match your workload.

### Decision 2: What's the minimum we can build?

**Option A:** Build all the routers, services, config, then test
**Option B:** Build ONE endpoint, test it, then add layers

Your spec uses **layered architecture** (routers → services → core), but we're going to build **vertically first**:

1. One working endpoint
2. Add configuration
3. Add data models
4. Add more endpoints
5. Add services

**Why?** If step 1 doesn't work, nothing else matters.

---

## Part 3: Let's Build - The Absolute Minimum

### Step 1: Create the structure

Create these folders:

```
mastercam-pdm/
└── backend/
    └── app/
```

That's it for now. We'll add more as we need them.

---

### Step 2: Dependencies

Create `backend/requirements.txt` - **TYPE THIS, don't copy:**

```txt
fastapi==0.115.0
uvicorn[standard]==0.31.0
```

**Stop. Let's understand what you just typed:**

**`fastapi==0.115.0`** - The web framework

- The `==` pins the exact version (reproducibility over novelty)
- In manufacturing, "works today" > "latest features"

**`uvicorn[standard]==0.31.0`** - The server that runs FastAPI

- `[standard]` installs performance extras (websockets, etc.)
- FastAPI creates the blueprint, Uvicorn runs the engine

**Install them:**

```bash
cd backend
pip install -r requirements.txt
```

---

### Step 3: The Simplest Server (Build This in Tiny Pieces)

Create `backend/app/main.py`

**Wait - why `main.py` and not `run.py`?**

Good question! Convention:

- `run.py` = The launcher (finds ports, opens browsers) - external to the app
- `main.py` = The actual FastAPI application - the core

Your `run.py` does `uvicorn.run("app.main:app", ...)` - it's looking for `app` inside `app/main.py`.

---

### Piece 1: The Imports

**Type this:**

```python
from fastapi import FastAPI
```

**Stop. What did you just import?**

`FastAPI` is a class. We're going to create ONE instance of it. That instance IS your entire web application.

Think of it like: `FastAPI` is the blueprint for a CNC controller, and we're about to build one.

---

### Piece 2: Create the App Instance

**Type this (add to what you have):**

```python
from fastapi import FastAPI

app = FastAPI(
    title="Mastercam PDM",
    version="2.0"
)
```

**Stop. What just happened?**

We created the app object. This single `app` is:

- The router (decides which function handles which URL)
- The validator (checks incoming data)
- The serializer (converts Python → JSON)
- The documentation generator (creates `/docs`)

**The `title` and `version`** show up in the auto-generated docs at `/docs`.

---

### Piece 3: Your First Endpoint

**Type this:**

```python
from fastapi import FastAPI

app = FastAPI(
    title="Mastercam PDM",
    version="2.0"
)

@app.get("/health")
def health_check():
    return {"status": "healthy"}
```

**Stop. Let's break down that decorator line by line:**

**`@app.get("/health")`** - This is a decorator. What does it DO?

It tells FastAPI: "When someone sends a GET request to `/health`, call the function below."

**Decorators are instructions TO the framework, not FOR you.**

Without `@app.get()`, the function `health_check()` is just a function. WITH the decorator, FastAPI knows about it.

**Why the `@` syntax?** It's Python's way of wrapping functions. Equivalent to:

```python
def health_check():
    return {"status": "healthy"}

health_check = app.get("/health")(health_check)
```

But `@` is cleaner.

---

**The function itself:**

```python
def health_check():
    return {"status": "healthy"}
```

**What happens to that dictionary?**

1. FastAPI sees it's a `dict`
2. Converts it to JSON: `{"status": "healthy"}`
3. Sets header: `Content-Type: application/json`
4. Sends response to client

**You don't write ANY of that boilerplate.** FastAPI does it automatically.

---

### Piece 4: The Test Block

**Type this at the bottom:**

```python
from fastapi import FastAPI

app = FastAPI(
    title="Mastercam PDM",
    version="2.0"
)

@app.get("/health")
def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
```

**Stop. What's `if __name__ == "__main__":`?**

**The problem it solves:**

- When you run `python main.py`, Python sets `__name__ = "__main__"`
- When you do `from app.main import app`, Python sets `__name__ = "app.main"`

**Why does this matter?**

Later, your `run.py` will import this file. You don't want the server to start twice!

```python
# In run.py:
from app.main import app  # This imports the module
# If we didn't have the "if __name__" check, uvicorn.run() would execute here too!
```

**The `if` block means:** "Only start the server if this file is run directly."

---

**Inside the block:**

```python
import uvicorn
uvicorn.run(app, host="127.0.0.1", port=8000)
```

**Why import uvicorn INSIDE the if block?**

Because we only need it for direct testing. Your real `run.py` will handle uvicorn differently (it finds available ports, opens browsers, etc.).

**What does `uvicorn.run()` do?**

- Starts a server listening on `127.0.0.1:8000`
- Hands incoming requests to your `app` object
- Runs until you press Ctrl+C

---

## Part 4: Test What You Built

**Run it:**

```bash
python app/main.py
```

**You should see:**

```
INFO:     Started server process
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000
```

**Test it:**

Open your browser: `http://127.0.0.1:8000/health`

**You should see:**

```json
{ "status": "healthy" }
```

**Now visit:** `http://127.0.0.1:8000/docs`

**BOOM - Interactive API documentation!** Try clicking "GET /health" → "Try it out" → "Execute".

---

## Part 5: Understanding The Request Flow

When you visited `/health`, here's what happened:

```
1. Browser sends:     GET /health HTTP/1.1
                      ↓
2. Uvicorn receives:  Port 8000 listener catches it
                      ↓
3. Uvicorn to FastAPI: "Someone wants /health"
                      ↓
4. FastAPI router:    "Who handles /health? Ah, health_check()"
                      ↓
5. Your function:     Returns {"status": "healthy"}
                      ↓
6. FastAPI:           Converts to JSON, sets headers
                      ↓
7. Uvicorn:           Sends HTTP response back
                      ↓
8. Browser:           Displays {"status":"healthy"}
```

**This is the core loop.** Every endpoint you ever write follows this exact pattern.

---

## Part 6: Why We Started Here

**Question:** Why build a health check first?

**Answer:** It's the simplest proof that:

- Python is working
- FastAPI is installed correctly
- The import system works
- The routing works
- The server can start
- HTTP works end-to-end

**If this doesn't work, NOTHING else will.**

**This is called "building vertically"** - prove one thin slice works end-to-end before adding width.

---

## What You Have Now

```
backend/
├── app/
│   └── main.py      (20 lines)
└── requirements.txt  (2 lines)
```

**You've proven:**

- ✅ The server starts
- ✅ Routing works
- ✅ JSON serialization works
- ✅ Auto-docs work

**You haven't built yet:**

- Config system
- Data models
- Multiple routers
- Services
- Auth

---

## Before We Continue

**Stop and verify:**

1. **Did you TYPE the code?** (Not copy-paste)
2. **Does `/health` return JSON?**
3. **Did you explore `/docs`?**
4. **Do you understand the request flow?**
5. **Do you understand WHY we started with one endpoint?**

**Answer these questions (to yourself or to me):**

- What does the `@app.get()` decorator DO?
- Why is `if __name__ == "__main__":` important?
- What would happen if you returned a string instead of a dict?

---

**When you're ready, tell me:**

"Ready for the next piece - adding configuration"

**Then I'll teach you:**

- Why configuration management matters
- How to build a config system that adapts to different environments
- How to use Pydantic for validation (you have a great ConfigManager in your file - I'll teach you how to build it)

**At the end of that section, you can share your `config.py` and I'll incorporate the good patterns into the tutorial.**

Sound good?
