# Module 1: The Foundation - Project Structure and First Working Endpoints

## Objective

By the end of this module, you will have:

- A complete, professional project structure
- A running FastAPI server
- A health check endpoint that proves your server is alive
- A basic file list endpoint that returns mock data (we'll make it real in later modules)
- Deep understanding of why every file, folder, and line of code exists

## The Blueprint: Understanding Web Application Architecture

Before we write a single line of code, let's understand what we're building using a manufacturing analogy.

### The Factory Floor Analogy

Your PDM application is like a manufacturing facility:

- **The Backend (Python/FastAPI)**: This is your factory floor where all the actual work happens. When a request comes in (like "give me a list of files"), the backend processes it, talks to Git, checks permissions, and sends back a response.

- **The Frontend (JavaScript/HTML/CSS)**: This is your customer showroom. It's what people see and interact with. When someone clicks "Checkout File," the showroom sends a message to the factory floor to do the actual work.

- **The Git Repository**: This is your warehouse where all the parts (files) are stored with a complete history of every change.

- **FastAPI**: Think of this as your factory's conveyor belt system. It routes incoming requests to the right workstation (endpoint) and ensures everything moves smoothly.

Today, we're building the factory's foundation and getting the first two workstations operational.

---

## Step 1: Create the Project Structure

Create this exact folder structure. Each folder serves a specific purpose:

```
mastercam-pdm/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── api/
│   │   │   ├── __init__.py
│   │   │   ├── dependencies.py
│   │   │   └── routers/
│   │   │       ├── __init__.py
│   │   │       └── files.py
│   │   ├── core/
│   │   │   ├── __init__.py
│   │   │   └── config.py
│   │   ├── models/
│   │   │   ├── __init__.py
│   │   │   └── schemas.py
│   │   └── services/
│   │       └── __init__.py
│   ├── run.py
│   └── requirements.txt
└── README.md
```

### Why This Structure?

**The `backend/` folder**: This is the factory building. Everything related to the server lives here.

**The `app/` folder**: This is the main factory floor. The actual application code lives here. It's separate from `run.py` (the factory's power switch) to keep concerns separated.

**The `app/api/` folder**: This is the reception desk. It contains all the code that handles incoming HTTP requests. The `routers/` subfolder is like different departments - one for file operations, one for authentication, etc.

**The `app/core/` folder**: This contains the factory's fundamental systems - configuration, security, anything that's core to the entire operation.

**The `app/models/` folder**: These are the blueprints. They define what data structures look like (e.g., "A FileInfo object must have a filename, size, and locked_by field").

**The `app/services/` folder**: These are the specialized workstations. Each service handles a specific domain of business logic (Git operations, user authentication, metadata management).

**The `__init__.py` files**: These are special Python files that mark a directory as a "package." They can be empty, but they tell Python "this folder contains importable code." Think of them as the "This is a valid department" sign on each door.

---

## Step 2: Define Dependencies

Create `backend/requirements.txt`:

```txt
fastapi==0.115.0
uvicorn[standard]==0.31.0
pydantic==2.9.2
pydantic-settings==2.5.2
```

### Deep Dive: What Each Dependency Does

**`fastapi==0.115.0`**

FastAPI is the web framework - the conveyor belt system. It provides:

- **Routing**: Maps URLs like `/files` to Python functions
- **Automatic validation**: Checks that incoming data matches your specifications
- **Automatic documentation**: Generates interactive API docs at `/docs`
- **Modern async support**: Can handle many requests simultaneously without blocking

The `==0.115.0` pins the exact version. In production code, you want reproducible builds.

📚 **Learn more**: [FastAPI Documentation](https://fastapi.tiangolo.com/)

**`uvicorn[standard]==0.31.0`**

Uvicorn is the ASGI server - the factory's power generator.

- **ASGI** (Asynchronous Server Gateway Interface) is the modern Python standard for async web servers
- FastAPI generates the blueprint, but Uvicorn is what actually runs it
- The `[standard]` extra installs additional performance dependencies
- It listens on a port (like 8000), receives HTTP requests, and hands them to FastAPI

📚 **Learn more**: [Uvicorn Documentation](https://www.uvicorn.org/)

**`pydantic==2.9.2`**

Pydantic is your quality control inspector. It:

- Defines data models using Python type hints
- Automatically validates data against those models
- Provides clear error messages when validation fails
- Serializes/deserializes data (Python objects ↔ JSON)

Example: If your `FileInfo` model says `size` must be an integer, Pydantic will reject `size="big"`.

📚 **Learn more**: [Pydantic Documentation](https://docs.pydantic.dev/)

**`pydantic-settings==2.5.2`**

This extends Pydantic to handle configuration settings. It can:

- Load settings from environment variables
- Load from `.env` files
- Validate configuration at startup (fail fast if config is wrong)

We'll use this to manage things like "where is the Git repo?" and "what port should we run on?"

📚 **Learn more**: [Pydantic Settings](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)

### Install the Dependencies

Open your terminal, navigate to the `backend/` directory, and run:

```bash
pip install -r requirements.txt
```

This tells Python's package manager to install all four packages (and their dependencies).

---

## Step 3: Create the Configuration System

Configuration is how your application adapts to different environments (development, production, etc.) without changing code.

### Create `backend/app/core/config.py`:

```python
"""
Core configuration module.

This module defines the Settings class which holds all application-wide
configuration. It uses Pydantic Settings to load values from environment
variables, making the app configurable without code changes.
"""

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.

    This class uses Pydantic's BaseSettings to automatically load configuration
    from environment variables. Any attribute defined here can be overridden
    by setting an environment variable with the same name (case-insensitive).

    Example:
        To override app_name, set environment variable: APP_NAME="My Custom Name"
    """

    # Basic application metadata
    app_name: str = "Mastercam PDM"
    app_version: str = "2.0"

    # Server configuration
    host: str = "127.0.0.1"
    port: int = 8000
    debug: bool = True

    # Model configuration - tells Pydantic where to look for settings
    model_config = SettingsConfigDict(
        env_file=".env",  # Load from .env file if it exists
        env_file_encoding="utf-8",
        case_sensitive=False  # APP_NAME and app_name both work
    )


# Create a singleton instance
# This is created once when the module is imported, not on every request
settings = Settings()
```

### Deep Dive: Understanding This Configuration System

**The Module Docstring** (`"""Core configuration module..."""`)

The triple-quoted string at the top is a docstring. It's not a comment (which uses `#`). Python treats docstrings specially - they become the `__doc__` attribute of the module and show up in help systems. Always write docstrings for modules, classes, and functions.

📚 **Learn more**: [PEP 257 - Docstring Conventions](https://peps.python.org/pep-0257/)

**The Import Statement**

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
```

This imports two items from the `pydantic_settings` package:

- `BaseSettings`: A base class we'll inherit from. It provides all the magic for loading settings from environment variables.
- `SettingsConfigDict`: A configuration object that tells BaseSettings HOW to load settings (from `.env` file, case sensitivity, etc.)

The `from ... import ...` syntax means "go into this package and bring specific items into my namespace." This is more precise than `import pydantic_settings` which would require us to write `pydantic_settings.BaseSettings` every time.

**The Settings Class**

```python
class Settings(BaseSettings):
```

This creates a new class named `Settings` that inherits from `BaseSettings`. Inheritance means our `Settings` class automatically gets all the functionality that `BaseSettings` provides (environment variable loading, validation, etc.).

Think of it like this: `BaseSettings` is the standard factory template, and we're customizing it for our specific factory.

**Class Docstring**

The docstring for the class explains what the class does and provides usage examples. Good documentation is crucial for future you (and other developers).

**Type-Annotated Attributes**

```python
app_name: str = "Mastercam PDM"
```

This line does several things:

1. **Declares an attribute**: `app_name` is a setting our app can use
2. **Type annotation**: `: str` tells Python (and Pydantic) this must be a string
3. **Default value**: `= "Mastercam PDM"` is what's used if no environment variable is set

When the Settings object is created, Pydantic:

1. Looks for an environment variable named `APP_NAME` (or `app_name`)
2. If found, uses that value (after validating it's a string)
3. If not found, uses the default value

**The port setting**

```python
port: int = 8000
```

This uses type annotation `: int`. If someone sets `PORT=hello`, Pydantic will try to convert it to an integer, fail, and raise a validation error at startup. This is **fail-fast** behavior - better to crash immediately with a clear error than run with bad config.

**The model_config Attribute**

```python
model_config = SettingsConfigDict(
    env_file=".env",
    env_file_encoding="utf-8",
    case_sensitive=False
)
```

This is configuration for the configuration system (meta-configuration). It tells Pydantic's BaseSettings:

- `env_file=".env"`: Also look for a file named `.env` in the working directory and load key-value pairs from it
- `env_file_encoding="utf-8"`: When reading that file, use UTF-8 encoding (handles international characters)
- `case_sensitive=False`: `app_name`, `APP_NAME`, and `App_Name` all refer to the same setting

📚 **Learn more**: [Pydantic Settings Configuration](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources)

**The Singleton Instance**

```python
settings = Settings()
```

This creates one instance of the Settings class when the module is first imported. This is a **singleton pattern** - there's only one Settings object for the entire application. Everyone who imports `settings` from this module gets the same object.

Why a singleton? Configuration is global state. Having multiple Settings objects with potentially different values would be confusing and error-prone.

---

## Step 4: Create Data Models

Data models are the contracts between different parts of your system. They define what data looks like.

### Create `backend/app/models/schemas.py`:

```python
"""
Data models (schemas) for the application.

These Pydantic models define the shape of data that flows through the API.
They provide automatic validation, serialization, and documentation.
"""

from typing import Optional
from pydantic import BaseModel, Field


class FileInfo(BaseModel):
    """
    Represents a single file in the repository.

    This is what gets sent to the frontend when listing files. Each field
    is validated automatically - if someone tries to create a FileInfo with
    a number for filename, Pydantic will reject it.
    """

    filename: str = Field(
        ...,
        description="The name of the file including extension",
        examples=["part_123.mcam", "fixture.emcam"]
    )

    path: str = Field(
        ...,
        description="Relative path from repository root",
        examples=["projects/2024/part_123.mcam"]
    )

    size: int = Field(
        ...,
        ge=0,
        description="File size in bytes"
    )

    locked_by: Optional[str] = Field(
        default=None,
        description="Username who has the file checked out, or None if available"
    )

    last_modified: Optional[str] = Field(
        default=None,
        description="ISO 8601 timestamp of last modification"
    )


class HealthResponse(BaseModel):
    """
    Response model for the health check endpoint.

    Simple status indicator to verify the server is running.
    """

    status: str = Field(
        default="healthy",
        description="Health status of the application"
    )

    app_name: str = Field(
        ...,
        description="Name of the application"
    )

    version: str = Field(
        ...,
        description="Current version of the application"
    )
```

### Deep Dive: Understanding Pydantic Models

**Imports**

```python
from typing import Optional
from pydantic import BaseModel, Field
```

- `Optional`: A type hint that means "this can be the specified type OR None". `Optional[str]` means "a string or None"
- `BaseModel`: The base class for all Pydantic models. Provides validation and serialization
- `Field`: A function that provides extra metadata and validation for model fields

**The FileInfo Model**

```python
class FileInfo(BaseModel):
```

This creates a data model for file information. When you create a `FileInfo` object, Pydantic validates all the data.

**Using Field() for Rich Metadata**

```python
filename: str = Field(
    ...,
    description="The name of the file including extension",
    examples=["part_123.mcam", "fixture.emcam"]
)
```

Let's break down `Field()`:

- **First argument (`...`)**: This is Python's "Ellipsis" literal. In Pydantic, it means "this field is required". No default value.
- **`description`**: Documentation for this field. Shows up in the auto-generated API docs at `/docs`
- **`examples`**: Sample values. Also used in API documentation

**Validation Constraints**

```python
size: int = Field(
    ...,
    ge=0,
    description="File size in bytes"
)
```

The `ge=0` parameter means "greater than or equal to 0". If someone tries to create a `FileInfo` with `size=-100`, Pydantic will reject it with a validation error. This is **defensive programming** - invalid data never enters your system.

📚 **Learn more**: [Pydantic Field Validation](https://docs.pydantic.dev/latest/concepts/fields/)

**Optional Fields**

```python
locked_by: Optional[str] = Field(
    default=None,
    description="Username who has the file checked out, or None if available"
)
```

`Optional[str]` means this can be a string or `None`. The `default=None` means if you don't provide this field when creating a `FileInfo`, it'll automatically be `None`. Optional fields are how we handle nullable data.

**Why Models Matter**

Without these models, you'd have to manually check:

- Is filename a string?
- Is size a number?
- Is size negative?
- Is locked_by a string or None?

Pydantic does all this automatically, and provides clear error messages when validation fails.

---

## Step 5: Create the File Router

Routers group related endpoints together. Our files router will handle all file operations.

### Create `backend/app/api/routers/files.py`:

```python
"""
File management endpoints.

This router handles all operations related to listing, checking out,
and managing files in the Git repository.
"""

from typing import Dict, List
from fastapi import APIRouter, HTTPException
from app.models.schemas import FileInfo

# Create a router instance
# The prefix means all routes in this router start with /files
# Tags are used to group endpoints in the API documentation
router = APIRouter(
    prefix="/files",
    tags=["files"]
)


@router.get("/", response_model=Dict[str, List[FileInfo]])
async def list_files():
    """
    List all files in the repository.

    Returns files grouped by directory. For now, this returns mock data.
    In later modules, we'll integrate real Git operations.

    Returns:
        Dict mapping directory names to lists of FileInfo objects

    Example response:
        {
            "projects/2024": [
                {"filename": "part_123.mcam", "path": "projects/2024/part_123.mcam", ...},
                {"filename": "fixture.emcam", "path": "projects/2024/fixture.emcam", ...}
            ]
        }
    """

    # Mock data - we'll replace this with real Git operations later
    mock_files = [
        FileInfo(
            filename="sample_part.mcam",
            path="projects/2024/sample_part.mcam",
            size=2048576,  # 2MB in bytes
            locked_by=None,
            last_modified="2024-10-08T14:30:00Z"
        ),
        FileInfo(
            filename="test_fixture.emcam",
            path="projects/2024/test_fixture.emcam",
            size=1048576,  # 1MB in bytes
            locked_by="john_doe",
            last_modified="2024-10-07T09:15:00Z"
        )
    ]

    # Group by directory (extract directory from path)
    grouped: Dict[str, List[FileInfo]] = {}

    for file in mock_files:
        # Extract directory from path (everything before the last /)
        directory = "/".join(file.path.split("/")[:-1])

        if directory not in grouped:
            grouped[directory] = []

        grouped[directory].append(file)

    return grouped
```

### Deep Dive: Understanding FastAPI Routers

**The Module Docstring**

Every module should start with a docstring explaining its purpose.

**Imports**

```python
from typing import Dict, List
from fastapi import APIRouter, HTTPException
from app.models.schemas import FileInfo
```

- `Dict, List`: Type hints for dictionaries and lists. `Dict[str, List[FileInfo]]` means "a dictionary where keys are strings and values are lists of FileInfo objects"
- `APIRouter`: The router class. It's like a mini-application that can be plugged into the main app
- `HTTPException`: Used to return HTTP error responses (404, 500, etc.)
- `FileInfo`: Our data model from earlier

The import `from app.models.schemas import FileInfo` uses an absolute import starting from `app`. This works because `app` is a package (it has `__init__.py`).

**Creating the Router**

```python
router = APIRouter(
    prefix="/files",
    tags=["files"]
)
```

- `APIRouter()` creates a router instance
- `prefix="/files"` means all routes in this router are automatically prefixed. A route defined as `@router.get("/")` actually becomes `/files/`
- `tags=["files"]` is metadata for the automatic documentation. All endpoints in this router will be grouped under "files" in the `/docs` page

**The Endpoint Definition**

```python
@router.get("/", response_model=Dict[str, List[FileInfo]])
async def list_files():
```

Let's unpack this line by line:

**`@router.get("/")`** - This is a decorator. Decorators modify or wrap functions. This decorator:

- Registers this function as a route handler
- `.get` means it responds to HTTP GET requests
- `"/"` is the path relative to the router's prefix, so the full path is `/files/`

**`response_model=Dict[str, List[FileInfo]]`** - This tells FastAPI:

- The function returns a dictionary with string keys and lists of FileInfo as values
- FastAPI will validate the response against this model
- FastAPI will use this to generate JSON Schema in the docs

**`async def list_files():`** - This defines an asynchronous function:

- `async` means this function can use `await` for I/O operations
- Even though we don't `await` anything yet, using `async` is best practice for APIs
- FastAPI can run async functions concurrently, improving performance

📚 **Learn more**: [FastAPI Path Operations](https://fastapi.tiangolo.com/tutorial/path-params/)

**The Docstring**

```python
"""
List all files in the repository.
...
"""
```

FastAPI automatically uses this docstring as the endpoint's description in the `/docs` page. Always document your endpoints.

**Mock Data Creation**

```python
mock_files = [
    FileInfo(
        filename="sample_part.mcam",
        path="projects/2024/sample_part.mcam",
        size=2048576,
        locked_by=None,
        last_modified="2024-10-08T14:30:00Z"
    ),
    ...
]
```

We're creating `FileInfo` objects directly. Pydantic validates all the fields automatically. If we passed `size="big"`, it would raise a validation error immediately.

**Grouping Logic**

```python
for file in mock_files:
    directory = "/".join(file.path.split("/")[:-1])
```

This extracts the directory from the path:

- `file.path.split("/")` splits "projects/2024/sample_part.mcam" into `["projects", "2024", "sample_part.mcam"]`
- `[:-1]` gets all elements except the last (the filename), giving `["projects", "2024"]`
- `"/".join(...)` joins them back with "/", resulting in "projects/2024"

```python
if directory not in grouped:
    grouped[directory] = []

grouped[directory].append(file)
```

This is the standard pattern for grouping: check if the key exists, create an empty list if not, then append to the list.

**The Return Statement**

```python
return grouped
```

FastAPI automatically:

1. Validates `grouped` against the `response_model`
2. Converts `FileInfo` objects to JSON dictionaries
3. Sets the `Content-Type: application/json` header
4. Returns the HTTP response

---

## Step 6: Create the Main Application

This is where everything comes together.

### Create `backend/run.py`:

```python
"""
Application entry point.

This module creates and configures the FastAPI application, registers all
routers, and starts the Uvicorn server.
"""

from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

from app.core.config import settings
from app.api.routers import files


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan context manager for startup and shutdown events.

    This function runs when the application starts up (before the code block)
    and when it shuts down (after the code block). It's useful for:
    - Opening database connections
    - Starting background tasks
    - Loading resources into memory
    - Cleaning up on shutdown

    Args:
        app: The FastAPI application instance
    """
    # Startup
    print(f"🚀 Starting {settings.app_name} v{settings.app_version}")
    print(f"📡 Server will be available at http://{settings.host}:{settings.port}")
    print(f"📚 API documentation at http://{settings.host}:{settings.port}/docs")

    yield  # Server runs here

    # Shutdown
    print("👋 Shutting down gracefully...")


# Create the FastAPI application
app = FastAPI(
    title=settings.app_name,
    version=settings.app_version,
    description="A lightweight PDM system for Mastercam files using Git backend",
    lifespan=lifespan
)

# Configure CORS (Cross-Origin Resource Sharing)
# This allows the frontend (running on a different port) to access the API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Register routers
app.include_router(files.router, prefix="/api")


@app.get("/health")
async def health_check():
    """
    Health check endpoint.

    This is a simple endpoint that returns the application's health status.
    Useful for monitoring systems and ensuring the server is responsive.

    Returns:
        dict: Health status information
    """
    return {
        "status": "healthy",
        "app_name": settings.app_name,
        "version": settings.app_version
    }


if __name__ == "__main__":
    # This block only runs when you execute this file directly (python run.py)
    # It doesn't run when the module is imported elsewhere

    uvicorn.run(
        "run:app",  # Module:variable format
        host=settings.host,
        port=settings.port,
        reload=settings.debug  # Auto-reload on code changes when debug=True
    )
```

### Deep Dive: Understanding the Main Application

**Imports**

```python
from contextlib import asynccontextmanager
```

This imports a decorator for creating async context managers. Context managers are the `with` statement pattern in Python - they ensure cleanup happens even if errors occur.

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
```

- `FastAPI`: The main application class
- `CORSMiddleware`: Middleware for handling Cross-Origin Resource Sharing (CORS)

```python
import uvicorn
```

The ASGI server. We import it to call `uvicorn.run()` at the bottom.

```python
from app.core.config import settings
from app.api.routers import files
```

Importing our configuration and our files router. Notice the absolute imports from `app`.

**The Lifespan Context Manager**

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup code
    print(f"🚀 Starting {settings.app_name} v{settings.app_version}")

    yield  # Server runs

    # Shutdown code
    print("👋 Shutting down gracefully...")
```

This is a key concept:

1. Code before `yield` runs once at startup
2. The `yield` statement is where the server runs
3. Code after `yield` runs once at shutdown

This replaces the older `@app.on_event("startup")` pattern. It's better because:

- It's a proper context manager (exception-safe)
- Startup and shutdown are clearly paired
- You can share state between them

The `@asynccontextmanager` decorator turns this generator function into an async context manager.

📚 **Learn more**: [FastAPI Lifespan Events](https://fastapi.tiangolo.com/advanced/events/)

**Creating the FastAPI Application**

```python
app = FastAPI(
    title=settings.app_name,
    version=settings.app_version,
    description="A lightweight PDM system for Mastercam files using Git backend",
    lifespan=lifespan
)
```

This creates the main application object. The parameters:

- `title`, `version`, `description`: Used in the auto-generated OpenAPI documentation
- `lifespan`: Connects our lifespan context manager

**CORS Middleware**

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

Middleware is code that runs on every request. CORS middleware handles the browser's security policy:

- **The Problem**: Browsers block requests from `http://localhost:3000` (frontend) to `http://localhost:8000` (API) by default for security
- **The Solution**: The server must send CORS headers saying "I allow requests from localhost:3000"

The parameters:

- `allow_origins=["*"]`: Allow requests from any origin (development only!)
- `allow_credentials=True`: Allow cookies/auth headers
- `allow_methods=["*"]`: Allow GET, POST, PUT, DELETE, etc.
- `allow_headers=["*"]`: Allow any HTTP headers

⚠️ **Security Note**: In production, replace `["*"]` with specific origins like `["https://your-app.com"]`.

📚 **Learn more**: [FastAPI CORS](https://fastapi.tiangolo.com/tutorial/cors/)

**Registering Routers**

```python
app.include_router(files.router, prefix="/api")
```

This mounts the files router:

- `files.router` is the `APIRouter` instance we created in `files.py`
- `prefix="/api"` adds another level of prefixing

The full path for our list_files endpoint is now:

- Router prefix: `/files`
- App prefix: `/api`
- Route path: `/`
- **Final URL**: `/api/files/`

**The Health Check Endpoint**

```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "app_name": settings.app_name,
        "version": settings.app_version
    }
```

This is defined directly on `app`, not on a router. It's at the root level, so it's at `/health` (no `/api` prefix).

Health checks are important for:

- Monitoring systems (is the server up?)
- Load balancers (which instances are healthy?)
- Deployment systems (is the new version working?)

**The Main Block**

```python
if __name__ == "__main__":
    uvicorn.run(
        "run:app",
        host=settings.host,
        port=settings.port,
        reload=settings.debug
    )
```

**`if __name__ == "__main__":`** - This only runs when you execute the file directly (not when imported)

**`uvicorn.run()`** starts the server:

- `"run:app"`: String format meaning "in the module named 'run', find the variable named 'app'"
- `host` and `port`: Where to listen
- `reload=settings.debug`: If True, Uvicorn watches for file changes and automatically restarts

📚 **Learn more**: [Uvicorn Deployment](https://www.uvicorn.org/deployment/)

---

## Step 7: Test Your Application

Time to see the factory in action!

### Run the Server

Open your terminal in the `backend/` directory and run:

```bash
python run.py
```

You should see output like:

```
🚀 Starting Mastercam PDM v2.0
📡 Server will be available at http://127.0.0.1:8000
📚 API documentation at http://127.0.0.1:8000/docs
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process
```

### Test the Health Endpoint

Open your browser and go to: `http://127.0.0.1:8000/health`

You should see:

```json
{
  "status": "healthy",
  "app_name": "Mastercam PDM",
  "version": "2.0"
}
```

### Test the File List Endpoint

Go to: `http://127.0.0.1:8000/api/files/`

You should see your mock data:

```json
{
  "projects/2024": [
    {
      "filename": "sample_part.mcam",
      "path": "projects/2024/sample_part.mcam",
      "size": 2048576,
      "locked_by": null,
      "last_modified": "2024-10-08T14:30:00Z"
    },
    {
      "filename": "test_fixture.emcam",
      "path": "projects/2024/test_fixture.emcam",
      "size": 1048576,
      "locked_by": "john_doe",
      "last_modified": "2024-10-07T09:15:00Z"
    }
  ]
}
```

### Explore the Interactive Documentation

Go to: `http://127.0.0.1:8000/docs`

This is FastAPI's automatic interactive API documentation (Swagger UI). You can:

- See all your endpoints
- Read descriptions from your docstrings
- Try out endpoints directly from the browser
- See request/response models

Try clicking "GET /api/files/" → "Try it out" → "Execute". You'll see the response right there.

---

## What You've Built

You now have:

1. ✅ A professional project structure following industry best practices
2. ✅ A configuration system that adapts to different environments
3. ✅ Type-safe data models with automatic validation
4. ✅ A running FastAPI server with CORS configured
5. ✅ A health check endpoint for monitoring
6. ✅ A file list endpoint (currently with mock data)
7. ✅ Interactive API documentation at `/docs`

Your factory foundation is solid. The conveyor belts are running, the power is on, and we have our first two workstations operational.

In the next module, we'll add the Git integration service and make that file list endpoint return real data from a repository.
